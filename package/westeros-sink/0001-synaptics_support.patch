commit c857f9ede9ef83c08a49ca8c0ea65d08124edd6b
Author: Vijay Kumar Raju P <vijaykr@synaptics.com>
Date:   Fri Nov 17 16:15:37 2017 -0800

    syna westeros plugin.

diff --git a/syna/Makefile.am b/syna/Makefile.am
new file mode 100644
index 0000000..aa34985
--- /dev/null
+++ b/syna/Makefile.am
@@ -0,0 +1,59 @@
+#
+# If not stated otherwise in this file or this component's Licenses.txt file the
+# following copyright and licenses apply:
+#
+# Copyright 2016 RDK Management
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+AUTOMAKE_OPTIONS = subdir-objects
+
+SUBDIRS = 
+
+AM_CFLAGS = 
+
+AM_LDFLAGS = 
+
+lib_LTLIBRARIES = libwesteros_gl.la
+
+libwesteros_gl_la_SOURCES = westeros-gl/westeros-gl.cpp
+
+libwesteros_gl_la_include_HEADERS = westeros-gl/westeros-gl.h
+libwesteros_gl_la_includedir = $(includedir)
+libwesteros_gl_la_CXXFLAGS= $(AM_CFLAGS) 
+
+libwesteros_gl_la_LDFLAGS= \
+   $(AM_LDFLAGS)
+
+pkgconfigdir = $(libdir)/pkgconfig
+   
+distcleancheck_listfiles = *-libtool
+
+## IPK Generation Support
+IPK_GEN_PATH = $(abs_top_builddir)/ipk
+IPK_GEN_STAGING_DIR=$(abs_top_builddir)/staging_dir
+IPK_GEN_INPUT  = debian-binary control.tar.gz data.tar.gz
+IPK_GEN_OUTPUT = westeros-soc.ipk
+
+package_ipk:
+	@echo "Generating IPK Package"
+	$(MAKE) prefix=${abs_top_builddir}/staging_dir install
+	$(mkdir_p) $(IPK_GEN_STAGING_DIR)/usr/bin/
+	cp -af $(IPK_GEN_STAGING_DIR)/bin/* $(IPK_GEN_STAGING_DIR)/usr/bin/
+	tar -czvf $(IPK_GEN_PATH)/data.tar.gz -C $(IPK_GEN_STAGING_DIR) usr
+	tar -czvf $(IPK_GEN_PATH)/control.tar.gz -C $(IPK_GEN_PATH) control postinst prerm
+	cd $(IPK_GEN_PATH) && ar cr $(IPK_GEN_OUTPUT) $(IPK_GEN_INPUT) && cd -
+	rm -rf ${abs_top_builddir}/staging_dir
+	rm -rf $(abs_top_builddir)/ipk/control.tar.gz
+	rm -rf $(abs_top_builddir)/ipk/data.tar.gz
diff --git a/syna/Makefile.in b/syna/Makefile.in
new file mode 100644
index 0000000..a94077f
--- /dev/null
+++ b/syna/Makefile.in
@@ -0,0 +1,1071 @@
+# Makefile.in generated by automake 1.15 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994-2014 Free Software Foundation, Inc.
+
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+#
+# If not stated otherwise in this file or this component's Licenses.txt file the
+# following copyright and licenses apply:
+#
+# Copyright 2016 RDK Management
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+
+VPATH = @srcdir@
+am__is_gnu_make = { \
+  if test -z '$(MAKELEVEL)'; then \
+    false; \
+  elif test -n '$(MAKE_HOST)'; then \
+    true; \
+  elif test -n '$(MAKE_VERSION)' && test -n '$(CURDIR)'; then \
+    true; \
+  else \
+    false; \
+  fi; \
+}
+am__make_running_with_option = \
+  case $${target_option-} in \
+      ?) ;; \
+      *) echo "am__make_running_with_option: internal error: invalid" \
+              "target option '$${target_option-}' specified" >&2; \
+         exit 1;; \
+  esac; \
+  has_opt=no; \
+  sane_makeflags=$$MAKEFLAGS; \
+  if $(am__is_gnu_make); then \
+    sane_makeflags=$$MFLAGS; \
+  else \
+    case $$MAKEFLAGS in \
+      *\\[\ \	]*) \
+        bs=\\; \
+        sane_makeflags=`printf '%s\n' "$$MAKEFLAGS" \
+          | sed "s/$$bs$$bs[$$bs $$bs	]*//g"`;; \
+    esac; \
+  fi; \
+  skip_next=no; \
+  strip_trailopt () \
+  { \
+    flg=`printf '%s\n' "$$flg" | sed "s/$$1.*$$//"`; \
+  }; \
+  for flg in $$sane_makeflags; do \
+    test $$skip_next = yes && { skip_next=no; continue; }; \
+    case $$flg in \
+      *=*|--*) continue;; \
+        -*I) strip_trailopt 'I'; skip_next=yes;; \
+      -*I?*) strip_trailopt 'I';; \
+        -*O) strip_trailopt 'O'; skip_next=yes;; \
+      -*O?*) strip_trailopt 'O';; \
+        -*l) strip_trailopt 'l'; skip_next=yes;; \
+      -*l?*) strip_trailopt 'l';; \
+      -[dEDm]) skip_next=yes;; \
+      -[JT]) skip_next=yes;; \
+    esac; \
+    case $$flg in \
+      *$$target_option*) has_opt=yes; break;; \
+    esac; \
+  done; \
+  test $$has_opt = yes
+am__make_dryrun = (target_option=n; $(am__make_running_with_option))
+am__make_keepgoing = (target_option=k; $(am__make_running_with_option))
+pkgdatadir = $(datadir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkglibexecdir = $(libexecdir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = .
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/cfg/libtool.m4 \
+	$(top_srcdir)/cfg/ltoptions.m4 $(top_srcdir)/cfg/ltsugar.m4 \
+	$(top_srcdir)/cfg/ltversion.m4 \
+	$(top_srcdir)/cfg/lt~obsolete.m4 $(top_srcdir)/configure.ac
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+DIST_COMMON = $(srcdir)/Makefile.am $(top_srcdir)/configure \
+	$(am__configure_deps) $(libwesteros_gl_la_include_HEADERS) \
+	$(am__DIST_COMMON)
+am__CONFIG_DISTCLEAN_FILES = config.status config.cache config.log \
+ configure.lineno config.status.lineno
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/cfg/config.h
+CONFIG_CLEAN_FILES =
+CONFIG_CLEAN_VPATH_FILES =
+am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
+am__vpath_adj = case $$p in \
+    $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
+    *) f=$$p;; \
+  esac;
+am__strip_dir = f=`echo $$p | sed -e 's|^.*/||'`;
+am__install_max = 40
+am__nobase_strip_setup = \
+  srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*|]/\\\\&/g'`
+am__nobase_strip = \
+  for p in $$list; do echo "$$p"; done | sed -e "s|$$srcdirstrip/||"
+am__nobase_list = $(am__nobase_strip_setup); \
+  for p in $$list; do echo "$$p $$p"; done | \
+  sed "s| $$srcdirstrip/| |;"' / .*\//!s/ .*/ ./; s,\( .*\)/[^/]*$$,\1,' | \
+  $(AWK) 'BEGIN { files["."] = "" } { files[$$2] = files[$$2] " " $$1; \
+    if (++n[$$2] == $(am__install_max)) \
+      { print $$2, files[$$2]; n[$$2] = 0; files[$$2] = "" } } \
+    END { for (dir in files) print dir, files[dir] }'
+am__base_list = \
+  sed '$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;s/\n/ /g' | \
+  sed '$$!N;$$!N;$$!N;$$!N;s/\n/ /g'
+am__uninstall_files_from_dir = { \
+  test -z "$$files" \
+    || { test ! -d "$$dir" && test ! -f "$$dir" && test ! -r "$$dir"; } \
+    || { echo " ( cd '$$dir' && rm -f" $$files ")"; \
+         $(am__cd) "$$dir" && rm -f $$files; }; \
+  }
+am__installdirs = "$(DESTDIR)$(libdir)" \
+	"$(DESTDIR)$(libwesteros_gl_la_includedir)"
+LTLIBRARIES = $(lib_LTLIBRARIES)
+libwesteros_gl_la_LIBADD =
+am__dirstamp = $(am__leading_dot)dirstamp
+am_libwesteros_gl_la_OBJECTS =  \
+	westeros-gl/libwesteros_gl_la-westeros-gl.lo
+libwesteros_gl_la_OBJECTS = $(am_libwesteros_gl_la_OBJECTS)
+AM_V_lt = $(am__v_lt_@AM_V@)
+am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
+am__v_lt_0 = --silent
+am__v_lt_1 = 
+libwesteros_gl_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CXX \
+	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=link $(CXXLD) \
+	$(libwesteros_gl_la_CXXFLAGS) $(CXXFLAGS) \
+	$(libwesteros_gl_la_LDFLAGS) $(LDFLAGS) -o $@
+AM_V_P = $(am__v_P_@AM_V@)
+am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)
+am__v_P_0 = false
+am__v_P_1 = :
+AM_V_GEN = $(am__v_GEN_@AM_V@)
+am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)
+am__v_GEN_0 = @echo "  GEN     " $@;
+am__v_GEN_1 = 
+AM_V_at = $(am__v_at_@AM_V@)
+am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)
+am__v_at_0 = @
+am__v_at_1 = 
+DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)/cfg
+depcomp = $(SHELL) $(top_srcdir)/cfg/depcomp
+am__depfiles_maybe = depfiles
+am__mv = mv -f
+CXXCOMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
+	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)
+LTCXXCOMPILE = $(LIBTOOL) $(AM_V_lt) --tag=CXX $(AM_LIBTOOLFLAGS) \
+	$(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) \
+	$(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) \
+	$(AM_CXXFLAGS) $(CXXFLAGS)
+AM_V_CXX = $(am__v_CXX_@AM_V@)
+am__v_CXX_ = $(am__v_CXX_@AM_DEFAULT_V@)
+am__v_CXX_0 = @echo "  CXX     " $@;
+am__v_CXX_1 = 
+CXXLD = $(CXX)
+CXXLINK = $(LIBTOOL) $(AM_V_lt) --tag=CXX $(AM_LIBTOOLFLAGS) \
+	$(LIBTOOLFLAGS) --mode=link $(CXXLD) $(AM_CXXFLAGS) \
+	$(CXXFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
+AM_V_CXXLD = $(am__v_CXXLD_@AM_V@)
+am__v_CXXLD_ = $(am__v_CXXLD_@AM_DEFAULT_V@)
+am__v_CXXLD_0 = @echo "  CXXLD   " $@;
+am__v_CXXLD_1 = 
+SOURCES = $(libwesteros_gl_la_SOURCES)
+DIST_SOURCES = $(libwesteros_gl_la_SOURCES)
+RECURSIVE_TARGETS = all-recursive check-recursive cscopelist-recursive \
+	ctags-recursive dvi-recursive html-recursive info-recursive \
+	install-data-recursive install-dvi-recursive \
+	install-exec-recursive install-html-recursive \
+	install-info-recursive install-pdf-recursive \
+	install-ps-recursive install-recursive installcheck-recursive \
+	installdirs-recursive pdf-recursive ps-recursive \
+	tags-recursive uninstall-recursive
+am__can_run_installinfo = \
+  case $$AM_UPDATE_INFO_DIR in \
+    n|no|NO) false;; \
+    *) (install-info --version) >/dev/null 2>&1;; \
+  esac
+HEADERS = $(libwesteros_gl_la_include_HEADERS)
+RECURSIVE_CLEAN_TARGETS = mostlyclean-recursive clean-recursive	\
+  distclean-recursive maintainer-clean-recursive
+am__recursive_targets = \
+  $(RECURSIVE_TARGETS) \
+  $(RECURSIVE_CLEAN_TARGETS) \
+  $(am__extra_recursive_targets)
+AM_RECURSIVE_TARGETS = $(am__recursive_targets:-recursive=) TAGS CTAGS \
+	cscope distdir dist dist-all distcheck
+am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) $(LISP)
+# Read a list of newline-separated strings from the standard input,
+# and print each of them once, without duplicates.  Input order is
+# *not* preserved.
+am__uniquify_input = $(AWK) '\
+  BEGIN { nonempty = 0; } \
+  { items[$$0] = 1; nonempty = 1; } \
+  END { if (nonempty) { for (i in items) print i; }; } \
+'
+# Make sure the list of sources is unique.  This is necessary because,
+# e.g., the same source file might be shared among _SOURCES variables
+# for different programs/libraries.
+am__define_uniq_tagged_files = \
+  list='$(am__tagged_files)'; \
+  unique=`for i in $$list; do \
+    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+  done | $(am__uniquify_input)`
+ETAGS = etags
+CTAGS = ctags
+CSCOPE = cscope
+DIST_SUBDIRS = $(SUBDIRS)
+am__DIST_COMMON = $(srcdir)/Makefile.in $(top_srcdir)/cfg/compile \
+	$(top_srcdir)/cfg/config.guess $(top_srcdir)/cfg/config.h.in \
+	$(top_srcdir)/cfg/config.sub $(top_srcdir)/cfg/depcomp \
+	$(top_srcdir)/cfg/install-sh $(top_srcdir)/cfg/ltmain.sh \
+	$(top_srcdir)/cfg/missing cfg/compile cfg/config.guess \
+	cfg/config.sub cfg/depcomp cfg/install-sh cfg/ltmain.sh \
+	cfg/missing
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+distdir = $(PACKAGE)-$(VERSION)
+top_distdir = $(distdir)
+am__remove_distdir = \
+  if test -d "$(distdir)"; then \
+    find "$(distdir)" -type d ! -perm -200 -exec chmod u+w {} ';' \
+      && rm -rf "$(distdir)" \
+      || { sleep 5 && rm -rf "$(distdir)"; }; \
+  else :; fi
+am__post_remove_distdir = $(am__remove_distdir)
+am__relativize = \
+  dir0=`pwd`; \
+  sed_first='s,^\([^/]*\)/.*$$,\1,'; \
+  sed_rest='s,^[^/]*/*,,'; \
+  sed_last='s,^.*/\([^/]*\)$$,\1,'; \
+  sed_butlast='s,/*[^/]*$$,,'; \
+  while test -n "$$dir1"; do \
+    first=`echo "$$dir1" | sed -e "$$sed_first"`; \
+    if test "$$first" != "."; then \
+      if test "$$first" = ".."; then \
+        dir2=`echo "$$dir0" | sed -e "$$sed_last"`/"$$dir2"; \
+        dir0=`echo "$$dir0" | sed -e "$$sed_butlast"`; \
+      else \
+        first2=`echo "$$dir2" | sed -e "$$sed_first"`; \
+        if test "$$first2" = "$$first"; then \
+          dir2=`echo "$$dir2" | sed -e "$$sed_rest"`; \
+        else \
+          dir2="../$$dir2"; \
+        fi; \
+        dir0="$$dir0"/"$$first"; \
+      fi; \
+    fi; \
+    dir1=`echo "$$dir1" | sed -e "$$sed_rest"`; \
+  done; \
+  reldir="$$dir2"
+GZIP_ENV = --best
+DIST_ARCHIVES = $(distdir).tar.bz2
+DIST_TARGETS = dist-bzip2
+distuninstallcheck_listfiles = find . -type f -print
+am__distuninstallcheck_listfiles = $(distuninstallcheck_listfiles) \
+  | sed 's|^\./|$(prefix)/|' | grep -v '$(infodir)/dir$$'
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AM_DEFAULT_VERBOSITY = @AM_DEFAULT_VERBOSITY@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CXX = @CXX@
+CXXCPP = @CXXCPP@
+CXXDEPMODE = @CXXDEPMODE@
+CXXFLAGS = @CXXFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DLLTOOL = @DLLTOOL@
+DSYMUTIL = @DSYMUTIL@
+DUMPBIN = @DUMPBIN@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+FGREP = @FGREP@
+GLIB_CFLAGS = @GLIB_CFLAGS@
+GLIB_LIBS = @GLIB_LIBS@
+GREP = @GREP@
+GTHREAD_CFLAGS = @GTHREAD_CFLAGS@
+GTHREAD_LIBS = @GTHREAD_LIBS@
+GUPNP_VERSION = @GUPNP_VERSION@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LD = @LD@
+LDFLAGS = @LDFLAGS@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LIPO = @LIPO@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+LT_SYS_LIBRARY_PATH = @LT_SYS_LIBRARY_PATH@
+MAKEINFO = @MAKEINFO@
+MANIFEST_TOOL = @MANIFEST_TOOL@
+MKDIR_P = @MKDIR_P@
+NM = @NM@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+OTOOL = @OTOOL@
+OTOOL64 = @OTOOL64@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+PKG_CONFIG = @PKG_CONFIG@
+PKG_CONFIG_LIBDIR = @PKG_CONFIG_LIBDIR@
+PKG_CONFIG_PATH = @PKG_CONFIG_PATH@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STRIP = @STRIP@
+VERSION = @VERSION@
+WAYLANDLIB = @WAYLANDLIB@
+WAYLAND_CFLAGS = @WAYLAND_CFLAGS@
+WAYLAND_CLIENT_CFLAGS = @WAYLAND_CLIENT_CFLAGS@
+WAYLAND_CLIENT_LIBS = @WAYLAND_CLIENT_LIBS@
+WAYLAND_SERVER_CFLAGS = @WAYLAND_SERVER_CFLAGS@
+WAYLAND_SERVER_LIBS = @WAYLAND_SERVER_LIBS@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_AR = @ac_ct_AR@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_CXX = @ac_ct_CXX@
+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+plugindir = @plugindir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_build_prefix = @top_build_prefix@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+AUTOMAKE_OPTIONS = subdir-objects
+SUBDIRS = 
+AM_CFLAGS = 
+AM_LDFLAGS = 
+lib_LTLIBRARIES = libwesteros_gl.la
+libwesteros_gl_la_SOURCES = westeros-gl/westeros-gl.cpp
+libwesteros_gl_la_include_HEADERS = westeros-gl/westeros-gl.h
+libwesteros_gl_la_includedir = $(includedir)
+libwesteros_gl_la_CXXFLAGS = $(AM_CFLAGS) 
+libwesteros_gl_la_LDFLAGS = \
+   $(AM_LDFLAGS)
+
+pkgconfigdir = $(libdir)/pkgconfig
+distcleancheck_listfiles = *-libtool
+IPK_GEN_PATH = $(abs_top_builddir)/ipk
+IPK_GEN_STAGING_DIR = $(abs_top_builddir)/staging_dir
+IPK_GEN_INPUT = debian-binary control.tar.gz data.tar.gz
+IPK_GEN_OUTPUT = westeros-soc.ipk
+all: all-recursive
+
+.SUFFIXES:
+.SUFFIXES: .cpp .lo .o .obj
+am--refresh: Makefile
+	@:
+$(srcdir)/Makefile.in:  $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      echo ' cd $(srcdir) && $(AUTOMAKE) --foreign'; \
+	      $(am__cd) $(srcdir) && $(AUTOMAKE) --foreign \
+		&& exit 0; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign Makefile'; \
+	$(am__cd) $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    echo ' $(SHELL) ./config.status'; \
+	    $(SHELL) ./config.status;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	$(SHELL) ./config.status --recheck
+
+$(top_srcdir)/configure:  $(am__configure_deps)
+	$(am__cd) $(srcdir) && $(AUTOCONF)
+$(ACLOCAL_M4):  $(am__aclocal_m4_deps)
+	$(am__cd) $(srcdir) && $(ACLOCAL) $(ACLOCAL_AMFLAGS)
+$(am__aclocal_m4_deps):
+
+cfg/config.h: cfg/stamp-h1
+	@test -f $@ || rm -f cfg/stamp-h1
+	@test -f $@ || $(MAKE) $(AM_MAKEFLAGS) cfg/stamp-h1
+
+cfg/stamp-h1: $(top_srcdir)/cfg/config.h.in $(top_builddir)/config.status
+	@rm -f cfg/stamp-h1
+	cd $(top_builddir) && $(SHELL) ./config.status cfg/config.h
+$(top_srcdir)/cfg/config.h.in:  $(am__configure_deps) 
+	($(am__cd) $(top_srcdir) && $(AUTOHEADER))
+	rm -f cfg/stamp-h1
+	touch $@
+
+distclean-hdr:
+	-rm -f cfg/config.h cfg/stamp-h1
+
+install-libLTLIBRARIES: $(lib_LTLIBRARIES)
+	@$(NORMAL_INSTALL)
+	@list='$(lib_LTLIBRARIES)'; test -n "$(libdir)" || list=; \
+	list2=; for p in $$list; do \
+	  if test -f $$p; then \
+	    list2="$$list2 $$p"; \
+	  else :; fi; \
+	done; \
+	test -z "$$list2" || { \
+	  echo " $(MKDIR_P) '$(DESTDIR)$(libdir)'"; \
+	  $(MKDIR_P) "$(DESTDIR)$(libdir)" || exit 1; \
+	  echo " $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL) $(INSTALL_STRIP_FLAG) $$list2 '$(DESTDIR)$(libdir)'"; \
+	  $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL) $(INSTALL_STRIP_FLAG) $$list2 "$(DESTDIR)$(libdir)"; \
+	}
+
+uninstall-libLTLIBRARIES:
+	@$(NORMAL_UNINSTALL)
+	@list='$(lib_LTLIBRARIES)'; test -n "$(libdir)" || list=; \
+	for p in $$list; do \
+	  $(am__strip_dir) \
+	  echo " $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=uninstall rm -f '$(DESTDIR)$(libdir)/$$f'"; \
+	  $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=uninstall rm -f "$(DESTDIR)$(libdir)/$$f"; \
+	done
+
+clean-libLTLIBRARIES:
+	-test -z "$(lib_LTLIBRARIES)" || rm -f $(lib_LTLIBRARIES)
+	@list='$(lib_LTLIBRARIES)'; \
+	locs=`for p in $$list; do echo $$p; done | \
+	      sed 's|^[^/]*$$|.|; s|/[^/]*$$||; s|$$|/so_locations|' | \
+	      sort -u`; \
+	test -z "$$locs" || { \
+	  echo rm -f $${locs}; \
+	  rm -f $${locs}; \
+	}
+westeros-gl/$(am__dirstamp):
+	@$(MKDIR_P) westeros-gl
+	@: > westeros-gl/$(am__dirstamp)
+westeros-gl/$(DEPDIR)/$(am__dirstamp):
+	@$(MKDIR_P) westeros-gl/$(DEPDIR)
+	@: > westeros-gl/$(DEPDIR)/$(am__dirstamp)
+westeros-gl/libwesteros_gl_la-westeros-gl.lo:  \
+	westeros-gl/$(am__dirstamp) \
+	westeros-gl/$(DEPDIR)/$(am__dirstamp)
+
+libwesteros_gl.la: $(libwesteros_gl_la_OBJECTS) $(libwesteros_gl_la_DEPENDENCIES) $(EXTRA_libwesteros_gl_la_DEPENDENCIES) 
+	$(AM_V_CXXLD)$(libwesteros_gl_la_LINK) -rpath $(libdir) $(libwesteros_gl_la_OBJECTS) $(libwesteros_gl_la_LIBADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+	-rm -f westeros-gl/*.$(OBJEXT)
+	-rm -f westeros-gl/*.lo
+
+distclean-compile:
+	-rm -f *.tab.c
+
+@AMDEP_TRUE@@am__include@ @am__quote@westeros-gl/$(DEPDIR)/libwesteros_gl_la-westeros-gl.Plo@am__quote@
+
+.cpp.o:
+@am__fastdepCXX_TRUE@	$(AM_V_CXX)depbase=`echo $@ | sed 's|[^/]*$$|$(DEPDIR)/&|;s|\.o$$||'`;\
+@am__fastdepCXX_TRUE@	$(CXXCOMPILE) -MT $@ -MD -MP -MF $$depbase.Tpo -c -o $@ $< &&\
+@am__fastdepCXX_TRUE@	$(am__mv) $$depbase.Tpo $$depbase.Po
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	$(AM_V_CXX)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCXX_FALSE@	$(AM_V_CXX@am__nodep@)$(CXXCOMPILE) -c -o $@ $<
+
+.cpp.obj:
+@am__fastdepCXX_TRUE@	$(AM_V_CXX)depbase=`echo $@ | sed 's|[^/]*$$|$(DEPDIR)/&|;s|\.obj$$||'`;\
+@am__fastdepCXX_TRUE@	$(CXXCOMPILE) -MT $@ -MD -MP -MF $$depbase.Tpo -c -o $@ `$(CYGPATH_W) '$<'` &&\
+@am__fastdepCXX_TRUE@	$(am__mv) $$depbase.Tpo $$depbase.Po
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	$(AM_V_CXX)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCXX_FALSE@	$(AM_V_CXX@am__nodep@)$(CXXCOMPILE) -c -o $@ `$(CYGPATH_W) '$<'`
+
+.cpp.lo:
+@am__fastdepCXX_TRUE@	$(AM_V_CXX)depbase=`echo $@ | sed 's|[^/]*$$|$(DEPDIR)/&|;s|\.lo$$||'`;\
+@am__fastdepCXX_TRUE@	$(LTCXXCOMPILE) -MT $@ -MD -MP -MF $$depbase.Tpo -c -o $@ $< &&\
+@am__fastdepCXX_TRUE@	$(am__mv) $$depbase.Tpo $$depbase.Plo
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	$(AM_V_CXX)source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCXX_FALSE@	$(AM_V_CXX@am__nodep@)$(LTCXXCOMPILE) -c -o $@ $<
+
+westeros-gl/libwesteros_gl_la-westeros-gl.lo: westeros-gl/westeros-gl.cpp
+@am__fastdepCXX_TRUE@	$(AM_V_CXX)$(LIBTOOL) $(AM_V_lt) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libwesteros_gl_la_CXXFLAGS) $(CXXFLAGS) -MT westeros-gl/libwesteros_gl_la-westeros-gl.lo -MD -MP -MF westeros-gl/$(DEPDIR)/libwesteros_gl_la-westeros-gl.Tpo -c -o westeros-gl/libwesteros_gl_la-westeros-gl.lo `test -f 'westeros-gl/westeros-gl.cpp' || echo '$(srcdir)/'`westeros-gl/westeros-gl.cpp
+@am__fastdepCXX_TRUE@	$(AM_V_at)$(am__mv) westeros-gl/$(DEPDIR)/libwesteros_gl_la-westeros-gl.Tpo westeros-gl/$(DEPDIR)/libwesteros_gl_la-westeros-gl.Plo
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	$(AM_V_CXX)source='westeros-gl/westeros-gl.cpp' object='westeros-gl/libwesteros_gl_la-westeros-gl.lo' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCXX_FALSE@	$(AM_V_CXX@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libwesteros_gl_la_CXXFLAGS) $(CXXFLAGS) -c -o westeros-gl/libwesteros_gl_la-westeros-gl.lo `test -f 'westeros-gl/westeros-gl.cpp' || echo '$(srcdir)/'`westeros-gl/westeros-gl.cpp
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+	-rm -rf westeros-gl/.libs westeros-gl/_libs
+
+distclean-libtool:
+	-rm -f libtool config.lt
+install-libwesteros_gl_la_includeHEADERS: $(libwesteros_gl_la_include_HEADERS)
+	@$(NORMAL_INSTALL)
+	@list='$(libwesteros_gl_la_include_HEADERS)'; test -n "$(libwesteros_gl_la_includedir)" || list=; \
+	if test -n "$$list"; then \
+	  echo " $(MKDIR_P) '$(DESTDIR)$(libwesteros_gl_la_includedir)'"; \
+	  $(MKDIR_P) "$(DESTDIR)$(libwesteros_gl_la_includedir)" || exit 1; \
+	fi; \
+	for p in $$list; do \
+	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
+	  echo "$$d$$p"; \
+	done | $(am__base_list) | \
+	while read files; do \
+	  echo " $(INSTALL_HEADER) $$files '$(DESTDIR)$(libwesteros_gl_la_includedir)'"; \
+	  $(INSTALL_HEADER) $$files "$(DESTDIR)$(libwesteros_gl_la_includedir)" || exit $$?; \
+	done
+
+uninstall-libwesteros_gl_la_includeHEADERS:
+	@$(NORMAL_UNINSTALL)
+	@list='$(libwesteros_gl_la_include_HEADERS)'; test -n "$(libwesteros_gl_la_includedir)" || list=; \
+	files=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \
+	dir='$(DESTDIR)$(libwesteros_gl_la_includedir)'; $(am__uninstall_files_from_dir)
+
+# This directory's subdirectories are mostly independent; you can cd
+# into them and run 'make' without going through this Makefile.
+# To change the values of 'make' variables: instead of editing Makefiles,
+# (1) if the variable is set in 'config.status', edit 'config.status'
+#     (which will cause the Makefiles to be regenerated when you run 'make');
+# (2) otherwise, pass the desired values on the 'make' command line.
+$(am__recursive_targets):
+	@fail=; \
+	if $(am__make_keepgoing); then \
+	  failcom='fail=yes'; \
+	else \
+	  failcom='exit 1'; \
+	fi; \
+	dot_seen=no; \
+	target=`echo $@ | sed s/-recursive//`; \
+	case "$@" in \
+	  distclean-* | maintainer-clean-*) list='$(DIST_SUBDIRS)' ;; \
+	  *) list='$(SUBDIRS)' ;; \
+	esac; \
+	for subdir in $$list; do \
+	  echo "Making $$target in $$subdir"; \
+	  if test "$$subdir" = "."; then \
+	    dot_seen=yes; \
+	    local_target="$$target-am"; \
+	  else \
+	    local_target="$$target"; \
+	  fi; \
+	  ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
+	  || eval $$failcom; \
+	done; \
+	if test "$$dot_seen" = "no"; then \
+	  $(MAKE) $(AM_MAKEFLAGS) "$$target-am" || exit 1; \
+	fi; test -z "$$fail"
+
+ID: $(am__tagged_files)
+	$(am__define_uniq_tagged_files); mkid -fID $$unique
+tags: tags-recursive
+TAGS: tags
+
+tags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
+	set x; \
+	here=`pwd`; \
+	if ($(ETAGS) --etags-include --version) >/dev/null 2>&1; then \
+	  include_option=--etags-include; \
+	  empty_fix=.; \
+	else \
+	  include_option=--include; \
+	  empty_fix=; \
+	fi; \
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  if test "$$subdir" = .; then :; else \
+	    test ! -f $$subdir/TAGS || \
+	      set "$$@" "$$include_option=$$here/$$subdir/TAGS"; \
+	  fi; \
+	done; \
+	$(am__define_uniq_tagged_files); \
+	shift; \
+	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  if test $$# -gt 0; then \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      "$$@" $$unique; \
+	  else \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      $$unique; \
+	  fi; \
+	fi
+ctags: ctags-recursive
+
+CTAGS: ctags
+ctags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
+	$(am__define_uniq_tagged_files); \
+	test -z "$(CTAGS_ARGS)$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && $(am__cd) $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) "$$here"
+cscope: cscope.files
+	test ! -s cscope.files \
+	  || $(CSCOPE) -b -q $(AM_CSCOPEFLAGS) $(CSCOPEFLAGS) -i cscope.files $(CSCOPE_ARGS)
+clean-cscope:
+	-rm -f cscope.files
+cscope.files: clean-cscope cscopelist
+cscopelist: cscopelist-recursive
+
+cscopelist-am: $(am__tagged_files)
+	list='$(am__tagged_files)'; \
+	case "$(srcdir)" in \
+	  [\\/]* | ?:[\\/]*) sdir="$(srcdir)" ;; \
+	  *) sdir=$(subdir)/$(srcdir) ;; \
+	esac; \
+	for i in $$list; do \
+	  if test -f "$$i"; then \
+	    echo "$(subdir)/$$i"; \
+	  else \
+	    echo "$$sdir/$$i"; \
+	  fi; \
+	done >> $(top_builddir)/cscope.files
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+	-rm -f cscope.out cscope.in.out cscope.po.out cscope.files
+
+distdir: $(DISTFILES)
+	$(am__remove_distdir)
+	test -d "$(distdir)" || mkdir "$(distdir)"
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d "$(distdir)/$$file"; then \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
+	  else \
+	    test -f "$(distdir)/$$file" \
+	    || cp -p $$d/$$file "$(distdir)/$$file" \
+	    || exit 1; \
+	  fi; \
+	done
+	@list='$(DIST_SUBDIRS)'; for subdir in $$list; do \
+	  if test "$$subdir" = .; then :; else \
+	    $(am__make_dryrun) \
+	      || test -d "$(distdir)/$$subdir" \
+	      || $(MKDIR_P) "$(distdir)/$$subdir" \
+	      || exit 1; \
+	    dir1=$$subdir; dir2="$(distdir)/$$subdir"; \
+	    $(am__relativize); \
+	    new_distdir=$$reldir; \
+	    dir1=$$subdir; dir2="$(top_distdir)"; \
+	    $(am__relativize); \
+	    new_top_distdir=$$reldir; \
+	    echo " (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) top_distdir="$$new_top_distdir" distdir="$$new_distdir" \\"; \
+	    echo "     am__remove_distdir=: am__skip_length_check=: am__skip_mode_fix=: distdir)"; \
+	    ($(am__cd) $$subdir && \
+	      $(MAKE) $(AM_MAKEFLAGS) \
+	        top_distdir="$$new_top_distdir" \
+	        distdir="$$new_distdir" \
+		am__remove_distdir=: \
+		am__skip_length_check=: \
+		am__skip_mode_fix=: \
+	        distdir) \
+	      || exit 1; \
+	  fi; \
+	done
+	-test -n "$(am__skip_mode_fix)" \
+	|| find "$(distdir)" -type d ! -perm -755 \
+		-exec chmod u+rwx,go+rx {} \; -o \
+	  ! -type d ! -perm -444 -links 1 -exec chmod a+r {} \; -o \
+	  ! -type d ! -perm -400 -exec chmod a+r {} \; -o \
+	  ! -type d ! -perm -444 -exec $(install_sh) -c -m a+r {} {} \; \
+	|| chmod -R a+r "$(distdir)"
+dist-gzip: distdir
+	tardir=$(distdir) && $(am__tar) | GZIP=$(GZIP_ENV) gzip -c >$(distdir).tar.gz
+	$(am__post_remove_distdir)
+dist-bzip2: distdir
+	tardir=$(distdir) && $(am__tar) | BZIP2=$${BZIP2--9} bzip2 -c >$(distdir).tar.bz2
+	$(am__post_remove_distdir)
+
+dist-lzip: distdir
+	tardir=$(distdir) && $(am__tar) | lzip -c $${LZIP_OPT--9} >$(distdir).tar.lz
+	$(am__post_remove_distdir)
+
+dist-xz: distdir
+	tardir=$(distdir) && $(am__tar) | XZ_OPT=$${XZ_OPT--e} xz -c >$(distdir).tar.xz
+	$(am__post_remove_distdir)
+
+dist-tarZ: distdir
+	@echo WARNING: "Support for distribution archives compressed with" \
+		       "legacy program 'compress' is deprecated." >&2
+	@echo WARNING: "It will be removed altogether in Automake 2.0" >&2
+	tardir=$(distdir) && $(am__tar) | compress -c >$(distdir).tar.Z
+	$(am__post_remove_distdir)
+
+dist-shar: distdir
+	@echo WARNING: "Support for shar distribution archives is" \
+	               "deprecated." >&2
+	@echo WARNING: "It will be removed altogether in Automake 2.0" >&2
+	shar $(distdir) | GZIP=$(GZIP_ENV) gzip -c >$(distdir).shar.gz
+	$(am__post_remove_distdir)
+
+dist-zip: distdir
+	-rm -f $(distdir).zip
+	zip -rq $(distdir).zip $(distdir)
+	$(am__post_remove_distdir)
+
+dist dist-all:
+	$(MAKE) $(AM_MAKEFLAGS) $(DIST_TARGETS) am__post_remove_distdir='@:'
+	$(am__post_remove_distdir)
+
+# This target untars the dist file and tries a VPATH configuration.  Then
+# it guarantees that the distribution is self-contained by making another
+# tarfile.
+distcheck: dist
+	case '$(DIST_ARCHIVES)' in \
+	*.tar.gz*) \
+	  GZIP=$(GZIP_ENV) gzip -dc $(distdir).tar.gz | $(am__untar) ;;\
+	*.tar.bz2*) \
+	  bzip2 -dc $(distdir).tar.bz2 | $(am__untar) ;;\
+	*.tar.lz*) \
+	  lzip -dc $(distdir).tar.lz | $(am__untar) ;;\
+	*.tar.xz*) \
+	  xz -dc $(distdir).tar.xz | $(am__untar) ;;\
+	*.tar.Z*) \
+	  uncompress -c $(distdir).tar.Z | $(am__untar) ;;\
+	*.shar.gz*) \
+	  GZIP=$(GZIP_ENV) gzip -dc $(distdir).shar.gz | unshar ;;\
+	*.zip*) \
+	  unzip $(distdir).zip ;;\
+	esac
+	chmod -R a-w $(distdir)
+	chmod u+w $(distdir)
+	mkdir $(distdir)/_build $(distdir)/_build/sub $(distdir)/_inst
+	chmod a-w $(distdir)
+	test -d $(distdir)/_build || exit 0; \
+	dc_install_base=`$(am__cd) $(distdir)/_inst && pwd | sed -e 's,^[^:\\/]:[\\/],/,'` \
+	  && dc_destdir="$${TMPDIR-/tmp}/am-dc-$$$$/" \
+	  && am__cwd=`pwd` \
+	  && $(am__cd) $(distdir)/_build/sub \
+	  && ../../configure \
+	    $(AM_DISTCHECK_CONFIGURE_FLAGS) \
+	    $(DISTCHECK_CONFIGURE_FLAGS) \
+	    --srcdir=../.. --prefix="$$dc_install_base" \
+	  && $(MAKE) $(AM_MAKEFLAGS) \
+	  && $(MAKE) $(AM_MAKEFLAGS) dvi \
+	  && $(MAKE) $(AM_MAKEFLAGS) check \
+	  && $(MAKE) $(AM_MAKEFLAGS) install \
+	  && $(MAKE) $(AM_MAKEFLAGS) installcheck \
+	  && $(MAKE) $(AM_MAKEFLAGS) uninstall \
+	  && $(MAKE) $(AM_MAKEFLAGS) distuninstallcheck_dir="$$dc_install_base" \
+	        distuninstallcheck \
+	  && chmod -R a-w "$$dc_install_base" \
+	  && ({ \
+	       (cd ../.. && umask 077 && mkdir "$$dc_destdir") \
+	       && $(MAKE) $(AM_MAKEFLAGS) DESTDIR="$$dc_destdir" install \
+	       && $(MAKE) $(AM_MAKEFLAGS) DESTDIR="$$dc_destdir" uninstall \
+	       && $(MAKE) $(AM_MAKEFLAGS) DESTDIR="$$dc_destdir" \
+	            distuninstallcheck_dir="$$dc_destdir" distuninstallcheck; \
+	      } || { rm -rf "$$dc_destdir"; exit 1; }) \
+	  && rm -rf "$$dc_destdir" \
+	  && $(MAKE) $(AM_MAKEFLAGS) dist \
+	  && rm -rf $(DIST_ARCHIVES) \
+	  && $(MAKE) $(AM_MAKEFLAGS) distcleancheck \
+	  && cd "$$am__cwd" \
+	  || exit 1
+	$(am__post_remove_distdir)
+	@(echo "$(distdir) archives ready for distribution: "; \
+	  list='$(DIST_ARCHIVES)'; for i in $$list; do echo $$i; done) | \
+	  sed -e 1h -e 1s/./=/g -e 1p -e 1x -e '$$p' -e '$$x'
+distuninstallcheck:
+	@test -n '$(distuninstallcheck_dir)' || { \
+	  echo 'ERROR: trying to run $@ with an empty' \
+	       '$$(distuninstallcheck_dir)' >&2; \
+	  exit 1; \
+	}; \
+	$(am__cd) '$(distuninstallcheck_dir)' || { \
+	  echo 'ERROR: cannot chdir into $(distuninstallcheck_dir)' >&2; \
+	  exit 1; \
+	}; \
+	test `$(am__distuninstallcheck_listfiles) | wc -l` -eq 0 \
+	   || { echo "ERROR: files left after uninstall:" ; \
+	        if test -n "$(DESTDIR)"; then \
+	          echo "  (check DESTDIR support)"; \
+	        fi ; \
+	        $(distuninstallcheck_listfiles) ; \
+	        exit 1; } >&2
+distcleancheck: distclean
+	@if test '$(srcdir)' = . ; then \
+	  echo "ERROR: distcleancheck can only run from a VPATH build" ; \
+	  exit 1 ; \
+	fi
+	@test `$(distcleancheck_listfiles) | wc -l` -eq 0 \
+	  || { echo "ERROR: files left in build directory after distclean:" ; \
+	       $(distcleancheck_listfiles) ; \
+	       exit 1; } >&2
+check-am: all-am
+check: check-recursive
+all-am: Makefile $(LTLIBRARIES) $(HEADERS)
+installdirs: installdirs-recursive
+installdirs-am:
+	for dir in "$(DESTDIR)$(libdir)" "$(DESTDIR)$(libwesteros_gl_la_includedir)"; do \
+	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
+	done
+install: install-recursive
+install-exec: install-exec-recursive
+install-data: install-data-recursive
+uninstall: uninstall-recursive
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-recursive
+install-strip:
+	if test -z '$(STRIP)'; then \
+	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	      install; \
+	else \
+	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	    "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'" install; \
+	fi
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)
+	-rm -f westeros-gl/$(DEPDIR)/$(am__dirstamp)
+	-rm -f westeros-gl/$(am__dirstamp)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-recursive
+
+clean-am: clean-generic clean-libLTLIBRARIES clean-libtool \
+	mostlyclean-am
+
+distclean: distclean-recursive
+	-rm -f $(am__CONFIG_DISTCLEAN_FILES)
+	-rm -rf westeros-gl/$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-hdr distclean-libtool distclean-tags
+
+dvi: dvi-recursive
+
+dvi-am:
+
+html: html-recursive
+
+html-am:
+
+info: info-recursive
+
+info-am:
+
+install-data-am: install-libwesteros_gl_la_includeHEADERS
+
+install-dvi: install-dvi-recursive
+
+install-dvi-am:
+
+install-exec-am: install-libLTLIBRARIES
+
+install-html: install-html-recursive
+
+install-html-am:
+
+install-info: install-info-recursive
+
+install-info-am:
+
+install-man:
+
+install-pdf: install-pdf-recursive
+
+install-pdf-am:
+
+install-ps: install-ps-recursive
+
+install-ps-am:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-recursive
+	-rm -f $(am__CONFIG_DISTCLEAN_FILES)
+	-rm -rf $(top_srcdir)/autom4te.cache
+	-rm -rf westeros-gl/$(DEPDIR)
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-recursive
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool
+
+pdf: pdf-recursive
+
+pdf-am:
+
+ps: ps-recursive
+
+ps-am:
+
+uninstall-am: uninstall-libLTLIBRARIES \
+	uninstall-libwesteros_gl_la_includeHEADERS
+
+.MAKE: $(am__recursive_targets) install-am install-strip
+
+.PHONY: $(am__recursive_targets) CTAGS GTAGS TAGS all all-am \
+	am--refresh check check-am clean clean-cscope clean-generic \
+	clean-libLTLIBRARIES clean-libtool cscope cscopelist-am ctags \
+	ctags-am dist dist-all dist-bzip2 dist-gzip dist-lzip \
+	dist-shar dist-tarZ dist-xz dist-zip distcheck distclean \
+	distclean-compile distclean-generic distclean-hdr \
+	distclean-libtool distclean-tags distcleancheck distdir \
+	distuninstallcheck dvi dvi-am html html-am info info-am \
+	install install-am install-data install-data-am install-dvi \
+	install-dvi-am install-exec install-exec-am install-html \
+	install-html-am install-info install-info-am \
+	install-libLTLIBRARIES \
+	install-libwesteros_gl_la_includeHEADERS install-man \
+	install-pdf install-pdf-am install-ps install-ps-am \
+	install-strip installcheck installcheck-am installdirs \
+	installdirs-am maintainer-clean maintainer-clean-generic \
+	mostlyclean mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool pdf pdf-am ps ps-am tags tags-am uninstall \
+	uninstall-am uninstall-libLTLIBRARIES \
+	uninstall-libwesteros_gl_la_includeHEADERS
+
+.PRECIOUS: Makefile
+
+
+package_ipk:
+	@echo "Generating IPK Package"
+	$(MAKE) prefix=${abs_top_builddir}/staging_dir install
+	$(mkdir_p) $(IPK_GEN_STAGING_DIR)/usr/bin/
+	cp -af $(IPK_GEN_STAGING_DIR)/bin/* $(IPK_GEN_STAGING_DIR)/usr/bin/
+	tar -czvf $(IPK_GEN_PATH)/data.tar.gz -C $(IPK_GEN_STAGING_DIR) usr
+	tar -czvf $(IPK_GEN_PATH)/control.tar.gz -C $(IPK_GEN_PATH) control postinst prerm
+	cd $(IPK_GEN_PATH) && ar cr $(IPK_GEN_OUTPUT) $(IPK_GEN_INPUT) && cd -
+	rm -rf ${abs_top_builddir}/staging_dir
+	rm -rf $(abs_top_builddir)/ipk/control.tar.gz
+	rm -rf $(abs_top_builddir)/ipk/data.tar.gz
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff --git a/syna/configure.ac b/syna/configure.ac
new file mode 100644
index 0000000..191fcbe
--- /dev/null
+++ b/syna/configure.ac
@@ -0,0 +1,68 @@
+#
+# If not stated otherwise in this file or this component's Licenses.txt file the
+# following copyright and licenses apply:
+#
+# Copyright 2016 RDK Management
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+#                                               -*- Autoconf -*-
+# Process this file with autoconf to produce a configure script.
+
+dnl AC_PREREQ([2.65])
+AC_INIT(westeros-soc, version-1.0, pavan_nandyala2@cable.comcast.com,westeros-soc)
+AC_CONFIG_SRCDIR([])
+AC_CONFIG_HEADERS([cfg/config.h])
+AC_CONFIG_MACRO_DIR([cfg])
+AC_CONFIG_AUX_DIR([cfg])
+AM_INIT_AUTOMAKE([foreign no-dist-gzip dist-bzip2 1.9])
+LT_INIT
+
+# Checks for programs.
+AC_PROG_CC
+AC_PROG_INSTALL
+AC_PROG_MAKE_SET
+AC_PROG_CXX
+
+# Checks for header files.
+AC_CHECK_HEADERS([stdlib.h string.h unistd.h])
+
+# Checks for typedefs, structures, and compiler characteristics.
+AC_TYPE_SIZE_T
+AC_HEADER_STDBOOL
+
+IARM_CFLAGS=" "
+
+# Checks for library functions.
+#Add the subdirectories to be considered for building.
+SUBDIRS=" "
+#to setup m4 macros
+m4_ifdef([AM_SILENT_RULES],[AM_SILENT_RULES([yes])],
+[AM_DEFAULT_VERBOSITY=1
+AC_SUBST(AM_DEFAULT_VERBOSITY)])
+
+PKG_CHECK_MODULES([GLIB],[glib-2.0 >= 2.22.5])
+PKG_CHECK_MODULES([GTHREAD],[gthread-2.0 >= 2.38.2])
+PKG_CHECK_MODULES([WAYLAND_CLIENT],[wayland-client >= 1.6.0])
+PKG_CHECK_MODULES([WAYLAND_SERVER],[wayland-server >= 1.6.0])
+
+WAYLANDLIB="-lwayland-client"
+AC_SUBST(WAYLANDLIB)
+
+AC_CONFIG_FILES([Makefile])
+AC_SUBST(WAYLAND_CFLAGS)
+AC_SUBST(GUPNP_VERSION)
+AC_SUBST(plugindir)
+AC_OUTPUT
+
diff --git a/syna/westeros-gl/westeros-gl.cpp b/syna/westeros-gl/westeros-gl.cpp
new file mode 100644
index 0000000..f020c97
--- /dev/null
+++ b/syna/westeros-gl/westeros-gl.cpp
@@ -0,0 +1,234 @@
+/*
+ * If not stated otherwise in this file or this component's Licenses.txt file the
+ * following copyright and licenses apply:
+ *
+ * Copyright 2016 RDK Management
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+#include <dlfcn.h>
+#include <EGL/egl.h>
+#include "westeros-gl.h"
+
+
+/*
+ * WstGLNativePixmap:
+ */
+typedef struct _WstGLNativePixmap
+{
+   void *pixmap;
+   int width;
+   int height;
+} WstNativePixmap;
+
+typedef struct _WstGLNativeWindow
+{
+   public:
+     void swap() {} 
+   private:
+} WstGLNativeWindow;
+
+typedef struct _WstGLCtx 
+{
+  int refCnt;
+  NativeDisplayType display;
+  EGLDisplay dpy;
+} WstGLCtx;
+
+static WstGLCtx* g_wstCtx= NULL;
+
+typedef EGLDisplay (*PREALEGLGETDISPLAY)(EGLNativeDisplayType);
+static PREALEGLGETDISPLAY gRealEGLGetDisplay= 0;
+
+EGLAPI EGLDisplay EGLAPIENTRY eglGetDisplay(EGLNativeDisplayType displayId)
+{
+   EGLDisplay eglDisplay= EGL_NO_DISPLAY;
+
+   printf("westeros-gl: eglGetDisplay: enter: displayId %x\n", displayId);
+
+   if ( !g_wstCtx )
+   {
+      g_wstCtx= WstGLInit();
+   }
+
+   if ( !gRealEGLGetDisplay )
+   {
+      printf("westeros-gl: eglGetDisplay: failed linkage to underlying EGL impl\n" );
+      goto exit;
+   }
+
+   if ( displayId == EGL_DEFAULT_DISPLAY )
+   {
+      if ( !g_wstCtx->display )
+      {
+         g_wstCtx->display= fbGetDisplay( g_wstCtx );
+      }
+      if ( g_wstCtx->display )
+      {
+         g_wstCtx->dpy = gRealEGLGetDisplay( (NativeDisplayType)g_wstCtx->display );
+      }
+   }
+   else
+   {
+      g_wstCtx->dpy = gRealEGLGetDisplay(displayId);
+   }
+
+   if ( g_wstCtx->dpy )
+   {
+      eglDisplay= g_wstCtx->dpy;
+   }
+
+exit:
+
+   return eglDisplay;
+}
+
+
+WstGLCtx* WstGLInit()
+{
+   /*
+    *  Establish the overloading of a subset of EGL methods
+    */
+   if ( !gRealEGLGetDisplay )
+   {
+      gRealEGLGetDisplay= (PREALEGLGETDISPLAY)dlsym( RTLD_NEXT, "eglGetDisplay" );
+      printf("westeros-gl: wstGLInit: realEGLGetDisplay=%p\n", (void*)gRealEGLGetDisplay );
+      if ( !gRealEGLGetDisplay )
+      {
+         printf("westeros-gl: wstGLInit: unable to resolve eglGetDisplay\n");
+         goto exit;
+      }
+   }
+
+   if( g_wstCtx != NULL )
+   {
+      ++g_wstCtx->refCnt;
+      return g_wstCtx;
+   }
+
+   g_wstCtx= (WstGLCtx*)calloc(1, sizeof(WstGLCtx));
+   if ( g_wstCtx )
+   {
+      g_wstCtx->refCnt= 1;
+   }
+
+exit:
+
+   return g_wstCtx;
+}
+
+void WstGLTerm( WstGLCtx *ctx )
+{
+   if ( ctx )
+   {
+      if ( ctx != g_wstCtx )
+      {
+         printf("westeros-gl: WstGLTerm: bad ctx %p, should be %p\n", ctx, g_wstCtx );
+         return;
+      }
+
+      --ctx->refCnt;
+      if ( ctx->refCnt <= 0 )
+      {
+         if ( ctx->display )
+         {
+            fbDestroyDisplay(ctx->display);
+            ctx->display= NULL;
+         }
+
+         free( ctx );
+
+         g_wstCtx= 0;
+      }
+   }
+}
+
+/*
+ * WstGLCreateNativeWindow
+ * Create a native window suitable for use as an EGLNativeWindow
+ */
+void* WstGLCreateNativeWindow( WstGLCtx *ctx, int x, int y, int width, int height )
+{
+   void *nativeWindow= 0;
+   if ( ctx ) {
+       nativeWindow = fbCreateWindow(ctx->display, x, y, width, height);
+   }
+   return nativeWindow;   
+}
+
+/*
+ * WstGLDestroyNativeWindow
+ * Destroy a native window created by WstGLCreateNativeWindow
+ */
+void WstGLDestroyNativeWindow( WstGLCtx *ctx, void *nativeWindow )
+{
+   if ( ctx && nativeWindow) {
+       fbDestroyWindow(nativeWindow);
+   }
+}
+
+bool WstGLGetNativePixmap( WstGLCtx *ctx, void *nativeBuffer, void **nativePixmap )
+{
+   bool result= false;
+    
+   if ( ctx )
+   {
+      // Not yet required
+   }
+   
+   return result;
+}
+
+/*
+ * WstGLGetNativePixmapDimensions
+ * Get the dimensions of the WstGLNativePixmap
+ */
+void WstGLGetNativePixmapDimensions( WstGLCtx *ctx, void *nativePixmap, int *width, int *height )
+{
+   if ( ctx )
+   {
+      // Not yet required
+   }
+}
+
+/*
+ * WstGLReleaseNativePixmap
+ * Release a WstGLNativePixmap obtained via WstGLGetNativePixmap
+ */
+void WstGLReleaseNativePixmap( WstGLCtx *ctx, void *nativePixmap )
+{
+   if ( ctx )
+   {
+      // Not yet required
+   }
+}
+
+/*
+ * WstGLGetEGLNativePixmap
+ * Get the native pixmap usable as a EGL_NATIVE_PIXMAP_KHR for creating a texture
+ * from the provided WstGLNativePixmap instance
+ */
+EGLNativePixmapType WstGLGetEGLNativePixmap( WstGLCtx *ctx, void *nativePixmap )
+{
+   EGLNativePixmapType eglPixmap= 0;
+   
+   if ( nativePixmap )
+   {
+      // Not yet required
+   }
+   
+   return eglPixmap;
+}
+
diff --git a/syna/westeros-gl/westeros-gl.h b/syna/westeros-gl/westeros-gl.h
new file mode 100644
index 0000000..de6e436
--- /dev/null
+++ b/syna/westeros-gl/westeros-gl.h
@@ -0,0 +1,42 @@
+/*
+ * If not stated otherwise in this file or this component's Licenses.txt file the
+ * following copyright and licenses apply:
+ *
+ * Copyright 2016 RDK Management
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#ifndef _WESTEROS_GL_H
+#define _WESTEROS_GL_H
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <memory.h>
+
+#include <EGL/egl.h>
+#include <EGL/eglext.h>
+
+
+typedef struct _WstGLCtx WstGLCtx;
+
+WstGLCtx* WstGLInit();
+void WstGLTerm( WstGLCtx *ctx );
+void* WstGLCreateNativeWindow( WstGLCtx *ctx, int x, int y, int width, int height );
+void WstGLDestroyNativeWindow( WstGLCtx *ctx, void *nativeWindow );
+bool WstGLGetNativePixmap( WstGLCtx *ctx, void *nativeBuffer, void **nativePixmap );
+void WstGLGetNativePixmapDimensions( WstGLCtx *ctx, void *nativePixmap, int *width, int *height );
+void WstGLReleaseNativePixmap( WstGLCtx *ctx, void *nativePixmap );
+EGLNativePixmapType WstGLGetEGLNativePixmap( WstGLCtx *ctx, void *nativePixmap );
+
+#endif
+
diff --git a/syna/westeros-sink/Makefile.am b/syna/westeros-sink/Makefile.am
new file mode 100644
index 0000000..205d551
--- /dev/null
+++ b/syna/westeros-sink/Makefile.am
@@ -0,0 +1,69 @@
+#
+# If not stated otherwise in this file or this component's Licenses.txt file the
+# following copyright and licenses apply:
+#
+# Copyright 2016 RDK Management
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+## Copyright (c) 2013 Comcast. All rights reserved.
+
+AUTOMAKE_OPTIONS = subdir-objects
+
+SUBDIRS = 
+
+GST_BASE_CFLAGS ?=
+GST_BASE_LIBS ?=
+LIB_SUB_DIR= gstreamer-0.10
+
+AM_CFLAGS = $(GST_CFLAGS)
+
+AM_LDFLAGS = $(GST_LIBS)  $(GSTBASE_LIBS) $(WAYLANDLIB) -avoid-version
+AM_LDFLAGS += -L$(PKG_CONFIG_SYSROOT_DIR)/usr/lib/marvell/ -lOSAL -lampclient -lavutil
+
+plugin_LTLIBRARIES = libwesteros_sink.la
+
+libwesteros_sink_la_SOURCES = westeros-sink-soc.c westeros-sink.c
+
+libwesteros_sink_la_CFLAGS= \
+   $(AM_CFLAGS) \
+   $(GST_CFLAGS)
+   
+libwesteros_sink_la_LDFLAGS= \
+   $(AM_LDFLAGS) \
+   $(GST_LIBS)  $(GSTBASE_LIBS) $(WAYLANDLIB) -avoid-version \
+   -lwesteros_compositor \
+   -lwesteros_compositor -lwesteros_compositor -lwesteros_compositor -lwesteros_compositor -lwesteros_compositor -lwesteros_compositor -lwesteros_compositor -lwesteros_compositor -lwesteros_compositor -lwesteros_simplebuffer_client \
+   -lwesteros_simpleshell_client
+   
+distcleancheck_listfiles = *-libtool
+
+## IPK Generation Support
+libwesteros_sink_IPK_OUTDIR = $(abs_top_builddir)/ipk
+libwesteros_sink_IPK_STAGING_DIR=$(abs_top_builddir)/staging_dir
+libwesteros_sink_IPK_TMP_DIR=$(libwesteros_sink_IPK_STAGING_DIR)/ipk
+
+libwesteros_sink_CONTROL_FILES = control
+libwesteros_sink_IPK_FILES  = debian-binary control.tar.gz data.tar.gz
+libwesteros_sink_IPK_OUTPUT = libwesteros_sink.ipk
+
+package_ipk:
+	@echo "Generating IPK Package"
+	$(MAKE) prefix=$(libwesteros_sink_IPK_STAGING_DIR) install
+	$(mkdir_p) $(libwesteros_sink_IPK_TMP_DIR)/usr/lib/$(LIB_SUB_DIR)
+	cp -aRf $(libwesteros_sink_IPK_STAGING_DIR)/lib/$(LIB_SUB_DIR)/*.so $(libwesteros_sink_IPK_TMP_DIR)/usr/lib/$(LIB_SUB_DIR)
+	tar -czvf $(libwesteros_sink_IPK_OUTDIR)/data.tar.gz -C $(libwesteros_sink_IPK_TMP_DIR) usr
+	tar -czvf $(libwesteros_sink_IPK_OUTDIR)/control.tar.gz -C $(libwesteros_sink_IPK_OUTDIR) $(libwesteros_sink_CONTROL_FILES)
+	cd $(libwesteros_sink_IPK_OUTDIR) && ar cr $(libwesteros_sink_IPK_OUTPUT) $(libwesteros_sink_IPK_FILES) && cd -
+
diff --git a/syna/westeros-sink/Makefile.in b/syna/westeros-sink/Makefile.in
new file mode 100644
index 0000000..5452988
--- /dev/null
+++ b/syna/westeros-sink/Makefile.in
@@ -0,0 +1,1046 @@
+# Makefile.in generated by automake 1.15 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994-2014 Free Software Foundation, Inc.
+
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+#
+# If not stated otherwise in this file or this component's Licenses.txt file the
+# following copyright and licenses apply:
+#
+# Copyright 2016 RDK Management
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+VPATH = @srcdir@
+am__is_gnu_make = { \
+  if test -z '$(MAKELEVEL)'; then \
+    false; \
+  elif test -n '$(MAKE_HOST)'; then \
+    true; \
+  elif test -n '$(MAKE_VERSION)' && test -n '$(CURDIR)'; then \
+    true; \
+  else \
+    false; \
+  fi; \
+}
+am__make_running_with_option = \
+  case $${target_option-} in \
+      ?) ;; \
+      *) echo "am__make_running_with_option: internal error: invalid" \
+              "target option '$${target_option-}' specified" >&2; \
+         exit 1;; \
+  esac; \
+  has_opt=no; \
+  sane_makeflags=$$MAKEFLAGS; \
+  if $(am__is_gnu_make); then \
+    sane_makeflags=$$MFLAGS; \
+  else \
+    case $$MAKEFLAGS in \
+      *\\[\ \	]*) \
+        bs=\\; \
+        sane_makeflags=`printf '%s\n' "$$MAKEFLAGS" \
+          | sed "s/$$bs$$bs[$$bs $$bs	]*//g"`;; \
+    esac; \
+  fi; \
+  skip_next=no; \
+  strip_trailopt () \
+  { \
+    flg=`printf '%s\n' "$$flg" | sed "s/$$1.*$$//"`; \
+  }; \
+  for flg in $$sane_makeflags; do \
+    test $$skip_next = yes && { skip_next=no; continue; }; \
+    case $$flg in \
+      *=*|--*) continue;; \
+        -*I) strip_trailopt 'I'; skip_next=yes;; \
+      -*I?*) strip_trailopt 'I';; \
+        -*O) strip_trailopt 'O'; skip_next=yes;; \
+      -*O?*) strip_trailopt 'O';; \
+        -*l) strip_trailopt 'l'; skip_next=yes;; \
+      -*l?*) strip_trailopt 'l';; \
+      -[dEDm]) skip_next=yes;; \
+      -[JT]) skip_next=yes;; \
+    esac; \
+    case $$flg in \
+      *$$target_option*) has_opt=yes; break;; \
+    esac; \
+  done; \
+  test $$has_opt = yes
+am__make_dryrun = (target_option=n; $(am__make_running_with_option))
+am__make_keepgoing = (target_option=k; $(am__make_running_with_option))
+pkgdatadir = $(datadir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkglibexecdir = $(libexecdir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = .
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.ac
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+DIST_COMMON = $(srcdir)/Makefile.am $(top_srcdir)/configure \
+	$(am__configure_deps) $(am__DIST_COMMON)
+am__CONFIG_DISTCLEAN_FILES = config.status config.cache config.log \
+ configure.lineno config.status.lineno
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/cfg/config.h
+CONFIG_CLEAN_FILES =
+CONFIG_CLEAN_VPATH_FILES =
+am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
+am__vpath_adj = case $$p in \
+    $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
+    *) f=$$p;; \
+  esac;
+am__strip_dir = f=`echo $$p | sed -e 's|^.*/||'`;
+am__install_max = 40
+am__nobase_strip_setup = \
+  srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*|]/\\\\&/g'`
+am__nobase_strip = \
+  for p in $$list; do echo "$$p"; done | sed -e "s|$$srcdirstrip/||"
+am__nobase_list = $(am__nobase_strip_setup); \
+  for p in $$list; do echo "$$p $$p"; done | \
+  sed "s| $$srcdirstrip/| |;"' / .*\//!s/ .*/ ./; s,\( .*\)/[^/]*$$,\1,' | \
+  $(AWK) 'BEGIN { files["."] = "" } { files[$$2] = files[$$2] " " $$1; \
+    if (++n[$$2] == $(am__install_max)) \
+      { print $$2, files[$$2]; n[$$2] = 0; files[$$2] = "" } } \
+    END { for (dir in files) print dir, files[dir] }'
+am__base_list = \
+  sed '$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;s/\n/ /g' | \
+  sed '$$!N;$$!N;$$!N;$$!N;s/\n/ /g'
+am__uninstall_files_from_dir = { \
+  test -z "$$files" \
+    || { test ! -d "$$dir" && test ! -f "$$dir" && test ! -r "$$dir"; } \
+    || { echo " ( cd '$$dir' && rm -f" $$files ")"; \
+         $(am__cd) "$$dir" && rm -f $$files; }; \
+  }
+am__installdirs = "$(DESTDIR)$(plugindir)"
+LTLIBRARIES = $(plugin_LTLIBRARIES)
+libwesteros_sink_la_LIBADD =
+am_libwesteros_sink_la_OBJECTS =  \
+	libwesteros_sink_la-westeros-sink-soc.lo \
+	libwesteros_sink_la-westeros-sink.lo
+libwesteros_sink_la_OBJECTS = $(am_libwesteros_sink_la_OBJECTS)
+AM_V_lt = $(am__v_lt_@AM_V@)
+am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
+am__v_lt_0 = --silent
+am__v_lt_1 = 
+libwesteros_sink_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC \
+	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=link $(CCLD) \
+	$(libwesteros_sink_la_CFLAGS) $(CFLAGS) \
+	$(libwesteros_sink_la_LDFLAGS) $(LDFLAGS) -o $@
+AM_V_P = $(am__v_P_@AM_V@)
+am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)
+am__v_P_0 = false
+am__v_P_1 = :
+AM_V_GEN = $(am__v_GEN_@AM_V@)
+am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)
+am__v_GEN_0 = @echo "  GEN     " $@;
+am__v_GEN_1 = 
+AM_V_at = $(am__v_at_@AM_V@)
+am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)
+am__v_at_0 = @
+am__v_at_1 = 
+DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)/cfg
+depcomp = $(SHELL) $(top_srcdir)/cfg/depcomp
+am__depfiles_maybe = depfiles
+am__mv = mv -f
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
+	$(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) \
+	$(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) \
+	$(AM_CFLAGS) $(CFLAGS)
+AM_V_CC = $(am__v_CC_@AM_V@)
+am__v_CC_ = $(am__v_CC_@AM_DEFAULT_V@)
+am__v_CC_0 = @echo "  CC      " $@;
+am__v_CC_1 = 
+CCLD = $(CC)
+LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
+	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
+	$(AM_LDFLAGS) $(LDFLAGS) -o $@
+AM_V_CCLD = $(am__v_CCLD_@AM_V@)
+am__v_CCLD_ = $(am__v_CCLD_@AM_DEFAULT_V@)
+am__v_CCLD_0 = @echo "  CCLD    " $@;
+am__v_CCLD_1 = 
+SOURCES = $(libwesteros_sink_la_SOURCES)
+DIST_SOURCES = $(libwesteros_sink_la_SOURCES)
+RECURSIVE_TARGETS = all-recursive check-recursive cscopelist-recursive \
+	ctags-recursive dvi-recursive html-recursive info-recursive \
+	install-data-recursive install-dvi-recursive \
+	install-exec-recursive install-html-recursive \
+	install-info-recursive install-pdf-recursive \
+	install-ps-recursive install-recursive installcheck-recursive \
+	installdirs-recursive pdf-recursive ps-recursive \
+	tags-recursive uninstall-recursive
+am__can_run_installinfo = \
+  case $$AM_UPDATE_INFO_DIR in \
+    n|no|NO) false;; \
+    *) (install-info --version) >/dev/null 2>&1;; \
+  esac
+RECURSIVE_CLEAN_TARGETS = mostlyclean-recursive clean-recursive	\
+  distclean-recursive maintainer-clean-recursive
+am__recursive_targets = \
+  $(RECURSIVE_TARGETS) \
+  $(RECURSIVE_CLEAN_TARGETS) \
+  $(am__extra_recursive_targets)
+AM_RECURSIVE_TARGETS = $(am__recursive_targets:-recursive=) TAGS CTAGS \
+	cscope distdir dist dist-all distcheck
+am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) $(LISP)
+# Read a list of newline-separated strings from the standard input,
+# and print each of them once, without duplicates.  Input order is
+# *not* preserved.
+am__uniquify_input = $(AWK) '\
+  BEGIN { nonempty = 0; } \
+  { items[$$0] = 1; nonempty = 1; } \
+  END { if (nonempty) { for (i in items) print i; }; } \
+'
+# Make sure the list of sources is unique.  This is necessary because,
+# e.g., the same source file might be shared among _SOURCES variables
+# for different programs/libraries.
+am__define_uniq_tagged_files = \
+  list='$(am__tagged_files)'; \
+  unique=`for i in $$list; do \
+    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+  done | $(am__uniquify_input)`
+ETAGS = etags
+CTAGS = ctags
+CSCOPE = cscope
+DIST_SUBDIRS = $(SUBDIRS)
+am__DIST_COMMON = $(srcdir)/Makefile.in $(top_srcdir)/cfg/compile \
+	$(top_srcdir)/cfg/config.guess $(top_srcdir)/cfg/config.h.in \
+	$(top_srcdir)/cfg/config.sub $(top_srcdir)/cfg/depcomp \
+	$(top_srcdir)/cfg/install-sh $(top_srcdir)/cfg/ltmain.sh \
+	$(top_srcdir)/cfg/missing cfg/compile cfg/config.guess \
+	cfg/config.sub cfg/depcomp cfg/install-sh cfg/ltmain.sh \
+	cfg/missing
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+distdir = $(PACKAGE)-$(VERSION)
+top_distdir = $(distdir)
+am__remove_distdir = \
+  if test -d "$(distdir)"; then \
+    find "$(distdir)" -type d ! -perm -200 -exec chmod u+w {} ';' \
+      && rm -rf "$(distdir)" \
+      || { sleep 5 && rm -rf "$(distdir)"; }; \
+  else :; fi
+am__post_remove_distdir = $(am__remove_distdir)
+am__relativize = \
+  dir0=`pwd`; \
+  sed_first='s,^\([^/]*\)/.*$$,\1,'; \
+  sed_rest='s,^[^/]*/*,,'; \
+  sed_last='s,^.*/\([^/]*\)$$,\1,'; \
+  sed_butlast='s,/*[^/]*$$,,'; \
+  while test -n "$$dir1"; do \
+    first=`echo "$$dir1" | sed -e "$$sed_first"`; \
+    if test "$$first" != "."; then \
+      if test "$$first" = ".."; then \
+        dir2=`echo "$$dir0" | sed -e "$$sed_last"`/"$$dir2"; \
+        dir0=`echo "$$dir0" | sed -e "$$sed_butlast"`; \
+      else \
+        first2=`echo "$$dir2" | sed -e "$$sed_first"`; \
+        if test "$$first2" = "$$first"; then \
+          dir2=`echo "$$dir2" | sed -e "$$sed_rest"`; \
+        else \
+          dir2="../$$dir2"; \
+        fi; \
+        dir0="$$dir0"/"$$first"; \
+      fi; \
+    fi; \
+    dir1=`echo "$$dir1" | sed -e "$$sed_rest"`; \
+  done; \
+  reldir="$$dir2"
+GZIP_ENV = --best
+DIST_ARCHIVES = $(distdir).tar.bz2
+DIST_TARGETS = dist-bzip2
+distuninstallcheck_listfiles = find . -type f -print
+am__distuninstallcheck_listfiles = $(distuninstallcheck_listfiles) \
+  | sed 's|^\./|$(prefix)/|' | grep -v '$(infodir)/dir$$'
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AM_DEFAULT_VERBOSITY = @AM_DEFAULT_VERBOSITY@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CXX = @CXX@
+CXXCPP = @CXXCPP@
+CXXDEPMODE = @CXXDEPMODE@
+CXXFLAGS = @CXXFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DLLTOOL = @DLLTOOL@
+DSYMUTIL = @DSYMUTIL@
+DUMPBIN = @DUMPBIN@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+FGREP = @FGREP@
+GLIB_CFLAGS = @GLIB_CFLAGS@
+GLIB_LIBS = @GLIB_LIBS@
+GREP = @GREP@
+GSTBASE_CFLAGS = @GSTBASE_CFLAGS@
+GSTBASE_LIBS = @GSTBASE_LIBS@
+GST_CFLAGS = @GST_CFLAGS@
+GST_LIBS = @GST_LIBS@
+GST_MAJORMINOR = @GST_MAJORMINOR@
+GTHREAD_CFLAGS = @GTHREAD_CFLAGS@
+GTHREAD_LIBS = @GTHREAD_LIBS@
+GUPNP_VERSION = @GUPNP_VERSION@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LD = @LD@
+LDFLAGS = @LDFLAGS@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LIPO = @LIPO@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+LT_SYS_LIBRARY_PATH = @LT_SYS_LIBRARY_PATH@
+MAKEINFO = @MAKEINFO@
+MANIFEST_TOOL = @MANIFEST_TOOL@
+MKDIR_P = @MKDIR_P@
+NM = @NM@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+OTOOL = @OTOOL@
+OTOOL64 = @OTOOL64@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+PKG_CONFIG = @PKG_CONFIG@
+PKG_CONFIG_LIBDIR = @PKG_CONFIG_LIBDIR@
+PKG_CONFIG_PATH = @PKG_CONFIG_PATH@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STRIP = @STRIP@
+VERSION = @VERSION@
+WAYLANDLIB = @WAYLANDLIB@
+WAYLAND_CFLAGS = @WAYLAND_CFLAGS@
+WAYLAND_CLIENT_CFLAGS = @WAYLAND_CLIENT_CFLAGS@
+WAYLAND_CLIENT_LIBS = @WAYLAND_CLIENT_LIBS@
+WAYLAND_SERVER_CFLAGS = @WAYLAND_SERVER_CFLAGS@
+WAYLAND_SERVER_LIBS = @WAYLAND_SERVER_LIBS@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_AR = @ac_ct_AR@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_CXX = @ac_ct_CXX@
+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+plugindir = @plugindir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_build_prefix = @top_build_prefix@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+AUTOMAKE_OPTIONS = subdir-objects
+SUBDIRS = 
+LIB_SUB_DIR = gstreamer-0.10
+AM_CFLAGS = $(GST_CFLAGS)
+AM_LDFLAGS = $(GST_LIBS)  $(GSTBASE_LIBS) $(WAYLANDLIB) -avoid-version
+plugin_LTLIBRARIES = libwesteros_sink.la
+libwesteros_sink_la_SOURCES = westeros-sink-soc.c westeros-sink.c
+libwesteros_sink_la_CFLAGS = \
+   $(AM_CFLAGS) \
+   $(GST_CFLAGS)
+
+libwesteros_sink_la_LDFLAGS = \
+   $(AM_LDFLAGS) \
+   $(GST_LIBS)  $(GSTBASE_LIBS) $(WAYLANDLIB) -avoid-version \
+   -lwesteros_compositor \
+   -lwesteros_simplebuffer_client \
+   -lwesteros_simpleshell_client
+
+distcleancheck_listfiles = *-libtool
+libwesteros_sink_IPK_OUTDIR = $(abs_top_builddir)/ipk
+libwesteros_sink_IPK_STAGING_DIR = $(abs_top_builddir)/staging_dir
+libwesteros_sink_IPK_TMP_DIR = $(libwesteros_sink_IPK_STAGING_DIR)/ipk
+libwesteros_sink_CONTROL_FILES = control
+libwesteros_sink_IPK_FILES = debian-binary control.tar.gz data.tar.gz
+libwesteros_sink_IPK_OUTPUT = libwesteros_sink.ipk
+all: all-recursive
+
+.SUFFIXES:
+.SUFFIXES: .c .lo .o .obj
+am--refresh: Makefile
+	@:
+$(srcdir)/Makefile.in:  $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      echo ' cd $(srcdir) && $(AUTOMAKE) --foreign'; \
+	      $(am__cd) $(srcdir) && $(AUTOMAKE) --foreign \
+		&& exit 0; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign Makefile'; \
+	$(am__cd) $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    echo ' $(SHELL) ./config.status'; \
+	    $(SHELL) ./config.status;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	$(SHELL) ./config.status --recheck
+
+$(top_srcdir)/configure:  $(am__configure_deps)
+	$(am__cd) $(srcdir) && $(AUTOCONF)
+$(ACLOCAL_M4):  $(am__aclocal_m4_deps)
+	$(am__cd) $(srcdir) && $(ACLOCAL) $(ACLOCAL_AMFLAGS)
+$(am__aclocal_m4_deps):
+
+cfg/config.h: cfg/stamp-h1
+	@test -f $@ || rm -f cfg/stamp-h1
+	@test -f $@ || $(MAKE) $(AM_MAKEFLAGS) cfg/stamp-h1
+
+cfg/stamp-h1: $(top_srcdir)/cfg/config.h.in $(top_builddir)/config.status
+	@rm -f cfg/stamp-h1
+	cd $(top_builddir) && $(SHELL) ./config.status cfg/config.h
+$(top_srcdir)/cfg/config.h.in:  $(am__configure_deps) 
+	($(am__cd) $(top_srcdir) && $(AUTOHEADER))
+	rm -f cfg/stamp-h1
+	touch $@
+
+distclean-hdr:
+	-rm -f cfg/config.h cfg/stamp-h1
+
+install-pluginLTLIBRARIES: $(plugin_LTLIBRARIES)
+	@$(NORMAL_INSTALL)
+	@list='$(plugin_LTLIBRARIES)'; test -n "$(plugindir)" || list=; \
+	list2=; for p in $$list; do \
+	  if test -f $$p; then \
+	    list2="$$list2 $$p"; \
+	  else :; fi; \
+	done; \
+	test -z "$$list2" || { \
+	  echo " $(MKDIR_P) '$(DESTDIR)$(plugindir)'"; \
+	  $(MKDIR_P) "$(DESTDIR)$(plugindir)" || exit 1; \
+	  echo " $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL) $(INSTALL_STRIP_FLAG) $$list2 '$(DESTDIR)$(plugindir)'"; \
+	  $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL) $(INSTALL_STRIP_FLAG) $$list2 "$(DESTDIR)$(plugindir)"; \
+	}
+
+uninstall-pluginLTLIBRARIES:
+	@$(NORMAL_UNINSTALL)
+	@list='$(plugin_LTLIBRARIES)'; test -n "$(plugindir)" || list=; \
+	for p in $$list; do \
+	  $(am__strip_dir) \
+	  echo " $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=uninstall rm -f '$(DESTDIR)$(plugindir)/$$f'"; \
+	  $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=uninstall rm -f "$(DESTDIR)$(plugindir)/$$f"; \
+	done
+
+clean-pluginLTLIBRARIES:
+	-test -z "$(plugin_LTLIBRARIES)" || rm -f $(plugin_LTLIBRARIES)
+	@list='$(plugin_LTLIBRARIES)'; \
+	locs=`for p in $$list; do echo $$p; done | \
+	      sed 's|^[^/]*$$|.|; s|/[^/]*$$||; s|$$|/so_locations|' | \
+	      sort -u`; \
+	test -z "$$locs" || { \
+	  echo rm -f $${locs}; \
+	  rm -f $${locs}; \
+	}
+
+libwesteros_sink.la: $(libwesteros_sink_la_OBJECTS) $(libwesteros_sink_la_DEPENDENCIES) $(EXTRA_libwesteros_sink_la_DEPENDENCIES) 
+	$(AM_V_CCLD)$(libwesteros_sink_la_LINK) -rpath $(plugindir) $(libwesteros_sink_la_OBJECTS) $(libwesteros_sink_la_LIBADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libwesteros_sink_la-westeros-sink-soc.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libwesteros_sink_la-westeros-sink.Plo@am__quote@
+
+.c.o:
+@am__fastdepCC_TRUE@	$(AM_V_CC)depbase=`echo $@ | sed 's|[^/]*$$|$(DEPDIR)/&|;s|\.o$$||'`;\
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $$depbase.Tpo -c -o $@ $< &&\
+@am__fastdepCC_TRUE@	$(am__mv) $$depbase.Tpo $$depbase.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(COMPILE) -c -o $@ $<
+
+.c.obj:
+@am__fastdepCC_TRUE@	$(AM_V_CC)depbase=`echo $@ | sed 's|[^/]*$$|$(DEPDIR)/&|;s|\.obj$$||'`;\
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $$depbase.Tpo -c -o $@ `$(CYGPATH_W) '$<'` &&\
+@am__fastdepCC_TRUE@	$(am__mv) $$depbase.Tpo $$depbase.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(COMPILE) -c -o $@ `$(CYGPATH_W) '$<'`
+
+.c.lo:
+@am__fastdepCC_TRUE@	$(AM_V_CC)depbase=`echo $@ | sed 's|[^/]*$$|$(DEPDIR)/&|;s|\.lo$$||'`;\
+@am__fastdepCC_TRUE@	$(LTCOMPILE) -MT $@ -MD -MP -MF $$depbase.Tpo -c -o $@ $< &&\
+@am__fastdepCC_TRUE@	$(am__mv) $$depbase.Tpo $$depbase.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LTCOMPILE) -c -o $@ $<
+
+libwesteros_sink_la-westeros-sink-soc.lo: westeros-sink-soc.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libwesteros_sink_la_CFLAGS) $(CFLAGS) -MT libwesteros_sink_la-westeros-sink-soc.lo -MD -MP -MF $(DEPDIR)/libwesteros_sink_la-westeros-sink-soc.Tpo -c -o libwesteros_sink_la-westeros-sink-soc.lo `test -f 'westeros-sink-soc.c' || echo '$(srcdir)/'`westeros-sink-soc.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libwesteros_sink_la-westeros-sink-soc.Tpo $(DEPDIR)/libwesteros_sink_la-westeros-sink-soc.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='westeros-sink-soc.c' object='libwesteros_sink_la-westeros-sink-soc.lo' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libwesteros_sink_la_CFLAGS) $(CFLAGS) -c -o libwesteros_sink_la-westeros-sink-soc.lo `test -f 'westeros-sink-soc.c' || echo '$(srcdir)/'`westeros-sink-soc.c
+
+libwesteros_sink_la-westeros-sink.lo: westeros-sink.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libwesteros_sink_la_CFLAGS) $(CFLAGS) -MT libwesteros_sink_la-westeros-sink.lo -MD -MP -MF $(DEPDIR)/libwesteros_sink_la-westeros-sink.Tpo -c -o libwesteros_sink_la-westeros-sink.lo `test -f 'westeros-sink.c' || echo '$(srcdir)/'`westeros-sink.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libwesteros_sink_la-westeros-sink.Tpo $(DEPDIR)/libwesteros_sink_la-westeros-sink.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='westeros-sink.c' object='libwesteros_sink_la-westeros-sink.lo' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libwesteros_sink_la_CFLAGS) $(CFLAGS) -c -o libwesteros_sink_la-westeros-sink.lo `test -f 'westeros-sink.c' || echo '$(srcdir)/'`westeros-sink.c
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+distclean-libtool:
+	-rm -f libtool config.lt
+
+# This directory's subdirectories are mostly independent; you can cd
+# into them and run 'make' without going through this Makefile.
+# To change the values of 'make' variables: instead of editing Makefiles,
+# (1) if the variable is set in 'config.status', edit 'config.status'
+#     (which will cause the Makefiles to be regenerated when you run 'make');
+# (2) otherwise, pass the desired values on the 'make' command line.
+$(am__recursive_targets):
+	@fail=; \
+	if $(am__make_keepgoing); then \
+	  failcom='fail=yes'; \
+	else \
+	  failcom='exit 1'; \
+	fi; \
+	dot_seen=no; \
+	target=`echo $@ | sed s/-recursive//`; \
+	case "$@" in \
+	  distclean-* | maintainer-clean-*) list='$(DIST_SUBDIRS)' ;; \
+	  *) list='$(SUBDIRS)' ;; \
+	esac; \
+	for subdir in $$list; do \
+	  echo "Making $$target in $$subdir"; \
+	  if test "$$subdir" = "."; then \
+	    dot_seen=yes; \
+	    local_target="$$target-am"; \
+	  else \
+	    local_target="$$target"; \
+	  fi; \
+	  ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
+	  || eval $$failcom; \
+	done; \
+	if test "$$dot_seen" = "no"; then \
+	  $(MAKE) $(AM_MAKEFLAGS) "$$target-am" || exit 1; \
+	fi; test -z "$$fail"
+
+ID: $(am__tagged_files)
+	$(am__define_uniq_tagged_files); mkid -fID $$unique
+tags: tags-recursive
+TAGS: tags
+
+tags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
+	set x; \
+	here=`pwd`; \
+	if ($(ETAGS) --etags-include --version) >/dev/null 2>&1; then \
+	  include_option=--etags-include; \
+	  empty_fix=.; \
+	else \
+	  include_option=--include; \
+	  empty_fix=; \
+	fi; \
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  if test "$$subdir" = .; then :; else \
+	    test ! -f $$subdir/TAGS || \
+	      set "$$@" "$$include_option=$$here/$$subdir/TAGS"; \
+	  fi; \
+	done; \
+	$(am__define_uniq_tagged_files); \
+	shift; \
+	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  if test $$# -gt 0; then \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      "$$@" $$unique; \
+	  else \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      $$unique; \
+	  fi; \
+	fi
+ctags: ctags-recursive
+
+CTAGS: ctags
+ctags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
+	$(am__define_uniq_tagged_files); \
+	test -z "$(CTAGS_ARGS)$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && $(am__cd) $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) "$$here"
+cscope: cscope.files
+	test ! -s cscope.files \
+	  || $(CSCOPE) -b -q $(AM_CSCOPEFLAGS) $(CSCOPEFLAGS) -i cscope.files $(CSCOPE_ARGS)
+clean-cscope:
+	-rm -f cscope.files
+cscope.files: clean-cscope cscopelist
+cscopelist: cscopelist-recursive
+
+cscopelist-am: $(am__tagged_files)
+	list='$(am__tagged_files)'; \
+	case "$(srcdir)" in \
+	  [\\/]* | ?:[\\/]*) sdir="$(srcdir)" ;; \
+	  *) sdir=$(subdir)/$(srcdir) ;; \
+	esac; \
+	for i in $$list; do \
+	  if test -f "$$i"; then \
+	    echo "$(subdir)/$$i"; \
+	  else \
+	    echo "$$sdir/$$i"; \
+	  fi; \
+	done >> $(top_builddir)/cscope.files
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+	-rm -f cscope.out cscope.in.out cscope.po.out cscope.files
+
+distdir: $(DISTFILES)
+	$(am__remove_distdir)
+	test -d "$(distdir)" || mkdir "$(distdir)"
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d "$(distdir)/$$file"; then \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
+	  else \
+	    test -f "$(distdir)/$$file" \
+	    || cp -p $$d/$$file "$(distdir)/$$file" \
+	    || exit 1; \
+	  fi; \
+	done
+	@list='$(DIST_SUBDIRS)'; for subdir in $$list; do \
+	  if test "$$subdir" = .; then :; else \
+	    $(am__make_dryrun) \
+	      || test -d "$(distdir)/$$subdir" \
+	      || $(MKDIR_P) "$(distdir)/$$subdir" \
+	      || exit 1; \
+	    dir1=$$subdir; dir2="$(distdir)/$$subdir"; \
+	    $(am__relativize); \
+	    new_distdir=$$reldir; \
+	    dir1=$$subdir; dir2="$(top_distdir)"; \
+	    $(am__relativize); \
+	    new_top_distdir=$$reldir; \
+	    echo " (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) top_distdir="$$new_top_distdir" distdir="$$new_distdir" \\"; \
+	    echo "     am__remove_distdir=: am__skip_length_check=: am__skip_mode_fix=: distdir)"; \
+	    ($(am__cd) $$subdir && \
+	      $(MAKE) $(AM_MAKEFLAGS) \
+	        top_distdir="$$new_top_distdir" \
+	        distdir="$$new_distdir" \
+		am__remove_distdir=: \
+		am__skip_length_check=: \
+		am__skip_mode_fix=: \
+	        distdir) \
+	      || exit 1; \
+	  fi; \
+	done
+	-test -n "$(am__skip_mode_fix)" \
+	|| find "$(distdir)" -type d ! -perm -755 \
+		-exec chmod u+rwx,go+rx {} \; -o \
+	  ! -type d ! -perm -444 -links 1 -exec chmod a+r {} \; -o \
+	  ! -type d ! -perm -400 -exec chmod a+r {} \; -o \
+	  ! -type d ! -perm -444 -exec $(install_sh) -c -m a+r {} {} \; \
+	|| chmod -R a+r "$(distdir)"
+dist-gzip: distdir
+	tardir=$(distdir) && $(am__tar) | GZIP=$(GZIP_ENV) gzip -c >$(distdir).tar.gz
+	$(am__post_remove_distdir)
+dist-bzip2: distdir
+	tardir=$(distdir) && $(am__tar) | BZIP2=$${BZIP2--9} bzip2 -c >$(distdir).tar.bz2
+	$(am__post_remove_distdir)
+
+dist-lzip: distdir
+	tardir=$(distdir) && $(am__tar) | lzip -c $${LZIP_OPT--9} >$(distdir).tar.lz
+	$(am__post_remove_distdir)
+
+dist-xz: distdir
+	tardir=$(distdir) && $(am__tar) | XZ_OPT=$${XZ_OPT--e} xz -c >$(distdir).tar.xz
+	$(am__post_remove_distdir)
+
+dist-tarZ: distdir
+	@echo WARNING: "Support for distribution archives compressed with" \
+		       "legacy program 'compress' is deprecated." >&2
+	@echo WARNING: "It will be removed altogether in Automake 2.0" >&2
+	tardir=$(distdir) && $(am__tar) | compress -c >$(distdir).tar.Z
+	$(am__post_remove_distdir)
+
+dist-shar: distdir
+	@echo WARNING: "Support for shar distribution archives is" \
+	               "deprecated." >&2
+	@echo WARNING: "It will be removed altogether in Automake 2.0" >&2
+	shar $(distdir) | GZIP=$(GZIP_ENV) gzip -c >$(distdir).shar.gz
+	$(am__post_remove_distdir)
+
+dist-zip: distdir
+	-rm -f $(distdir).zip
+	zip -rq $(distdir).zip $(distdir)
+	$(am__post_remove_distdir)
+
+dist dist-all:
+	$(MAKE) $(AM_MAKEFLAGS) $(DIST_TARGETS) am__post_remove_distdir='@:'
+	$(am__post_remove_distdir)
+
+# This target untars the dist file and tries a VPATH configuration.  Then
+# it guarantees that the distribution is self-contained by making another
+# tarfile.
+distcheck: dist
+	case '$(DIST_ARCHIVES)' in \
+	*.tar.gz*) \
+	  GZIP=$(GZIP_ENV) gzip -dc $(distdir).tar.gz | $(am__untar) ;;\
+	*.tar.bz2*) \
+	  bzip2 -dc $(distdir).tar.bz2 | $(am__untar) ;;\
+	*.tar.lz*) \
+	  lzip -dc $(distdir).tar.lz | $(am__untar) ;;\
+	*.tar.xz*) \
+	  xz -dc $(distdir).tar.xz | $(am__untar) ;;\
+	*.tar.Z*) \
+	  uncompress -c $(distdir).tar.Z | $(am__untar) ;;\
+	*.shar.gz*) \
+	  GZIP=$(GZIP_ENV) gzip -dc $(distdir).shar.gz | unshar ;;\
+	*.zip*) \
+	  unzip $(distdir).zip ;;\
+	esac
+	chmod -R a-w $(distdir)
+	chmod u+w $(distdir)
+	mkdir $(distdir)/_build $(distdir)/_build/sub $(distdir)/_inst
+	chmod a-w $(distdir)
+	test -d $(distdir)/_build || exit 0; \
+	dc_install_base=`$(am__cd) $(distdir)/_inst && pwd | sed -e 's,^[^:\\/]:[\\/],/,'` \
+	  && dc_destdir="$${TMPDIR-/tmp}/am-dc-$$$$/" \
+	  && am__cwd=`pwd` \
+	  && $(am__cd) $(distdir)/_build/sub \
+	  && ../../configure \
+	    $(AM_DISTCHECK_CONFIGURE_FLAGS) \
+	    $(DISTCHECK_CONFIGURE_FLAGS) \
+	    --srcdir=../.. --prefix="$$dc_install_base" \
+	  && $(MAKE) $(AM_MAKEFLAGS) \
+	  && $(MAKE) $(AM_MAKEFLAGS) dvi \
+	  && $(MAKE) $(AM_MAKEFLAGS) check \
+	  && $(MAKE) $(AM_MAKEFLAGS) install \
+	  && $(MAKE) $(AM_MAKEFLAGS) installcheck \
+	  && $(MAKE) $(AM_MAKEFLAGS) uninstall \
+	  && $(MAKE) $(AM_MAKEFLAGS) distuninstallcheck_dir="$$dc_install_base" \
+	        distuninstallcheck \
+	  && chmod -R a-w "$$dc_install_base" \
+	  && ({ \
+	       (cd ../.. && umask 077 && mkdir "$$dc_destdir") \
+	       && $(MAKE) $(AM_MAKEFLAGS) DESTDIR="$$dc_destdir" install \
+	       && $(MAKE) $(AM_MAKEFLAGS) DESTDIR="$$dc_destdir" uninstall \
+	       && $(MAKE) $(AM_MAKEFLAGS) DESTDIR="$$dc_destdir" \
+	            distuninstallcheck_dir="$$dc_destdir" distuninstallcheck; \
+	      } || { rm -rf "$$dc_destdir"; exit 1; }) \
+	  && rm -rf "$$dc_destdir" \
+	  && $(MAKE) $(AM_MAKEFLAGS) dist \
+	  && rm -rf $(DIST_ARCHIVES) \
+	  && $(MAKE) $(AM_MAKEFLAGS) distcleancheck \
+	  && cd "$$am__cwd" \
+	  || exit 1
+	$(am__post_remove_distdir)
+	@(echo "$(distdir) archives ready for distribution: "; \
+	  list='$(DIST_ARCHIVES)'; for i in $$list; do echo $$i; done) | \
+	  sed -e 1h -e 1s/./=/g -e 1p -e 1x -e '$$p' -e '$$x'
+distuninstallcheck:
+	@test -n '$(distuninstallcheck_dir)' || { \
+	  echo 'ERROR: trying to run $@ with an empty' \
+	       '$$(distuninstallcheck_dir)' >&2; \
+	  exit 1; \
+	}; \
+	$(am__cd) '$(distuninstallcheck_dir)' || { \
+	  echo 'ERROR: cannot chdir into $(distuninstallcheck_dir)' >&2; \
+	  exit 1; \
+	}; \
+	test `$(am__distuninstallcheck_listfiles) | wc -l` -eq 0 \
+	   || { echo "ERROR: files left after uninstall:" ; \
+	        if test -n "$(DESTDIR)"; then \
+	          echo "  (check DESTDIR support)"; \
+	        fi ; \
+	        $(distuninstallcheck_listfiles) ; \
+	        exit 1; } >&2
+distcleancheck: distclean
+	@if test '$(srcdir)' = . ; then \
+	  echo "ERROR: distcleancheck can only run from a VPATH build" ; \
+	  exit 1 ; \
+	fi
+	@test `$(distcleancheck_listfiles) | wc -l` -eq 0 \
+	  || { echo "ERROR: files left in build directory after distclean:" ; \
+	       $(distcleancheck_listfiles) ; \
+	       exit 1; } >&2
+check-am: all-am
+check: check-recursive
+all-am: Makefile $(LTLIBRARIES)
+installdirs: installdirs-recursive
+installdirs-am:
+	for dir in "$(DESTDIR)$(plugindir)"; do \
+	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
+	done
+install: install-recursive
+install-exec: install-exec-recursive
+install-data: install-data-recursive
+uninstall: uninstall-recursive
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-recursive
+install-strip:
+	if test -z '$(STRIP)'; then \
+	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	      install; \
+	else \
+	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	    "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'" install; \
+	fi
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-recursive
+
+clean-am: clean-generic clean-libtool clean-pluginLTLIBRARIES \
+	mostlyclean-am
+
+distclean: distclean-recursive
+	-rm -f $(am__CONFIG_DISTCLEAN_FILES)
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-hdr distclean-libtool distclean-tags
+
+dvi: dvi-recursive
+
+dvi-am:
+
+html: html-recursive
+
+html-am:
+
+info: info-recursive
+
+info-am:
+
+install-data-am: install-pluginLTLIBRARIES
+
+install-dvi: install-dvi-recursive
+
+install-dvi-am:
+
+install-exec-am:
+
+install-html: install-html-recursive
+
+install-html-am:
+
+install-info: install-info-recursive
+
+install-info-am:
+
+install-man:
+
+install-pdf: install-pdf-recursive
+
+install-pdf-am:
+
+install-ps: install-ps-recursive
+
+install-ps-am:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-recursive
+	-rm -f $(am__CONFIG_DISTCLEAN_FILES)
+	-rm -rf $(top_srcdir)/autom4te.cache
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-recursive
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool
+
+pdf: pdf-recursive
+
+pdf-am:
+
+ps: ps-recursive
+
+ps-am:
+
+uninstall-am: uninstall-pluginLTLIBRARIES
+
+.MAKE: $(am__recursive_targets) install-am install-strip
+
+.PHONY: $(am__recursive_targets) CTAGS GTAGS TAGS all all-am \
+	am--refresh check check-am clean clean-cscope clean-generic \
+	clean-libtool clean-pluginLTLIBRARIES cscope cscopelist-am \
+	ctags ctags-am dist dist-all dist-bzip2 dist-gzip dist-lzip \
+	dist-shar dist-tarZ dist-xz dist-zip distcheck distclean \
+	distclean-compile distclean-generic distclean-hdr \
+	distclean-libtool distclean-tags distcleancheck distdir \
+	distuninstallcheck dvi dvi-am html html-am info info-am \
+	install install-am install-data install-data-am install-dvi \
+	install-dvi-am install-exec install-exec-am install-html \
+	install-html-am install-info install-info-am install-man \
+	install-pdf install-pdf-am install-pluginLTLIBRARIES \
+	install-ps install-ps-am install-strip installcheck \
+	installcheck-am installdirs installdirs-am maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-compile \
+	mostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \
+	tags tags-am uninstall uninstall-am \
+	uninstall-pluginLTLIBRARIES
+
+.PRECIOUS: Makefile
+
+
+GST_BASE_CFLAGS ?=
+GST_BASE_LIBS ?=
+
+package_ipk:
+	@echo "Generating IPK Package"
+	$(MAKE) prefix=$(libwesteros_sink_IPK_STAGING_DIR) install
+	$(mkdir_p) $(libwesteros_sink_IPK_TMP_DIR)/usr/lib/$(LIB_SUB_DIR)
+	cp -aRf $(libwesteros_sink_IPK_STAGING_DIR)/lib/$(LIB_SUB_DIR)/*.so $(libwesteros_sink_IPK_TMP_DIR)/usr/lib/$(LIB_SUB_DIR)
+	tar -czvf $(libwesteros_sink_IPK_OUTDIR)/data.tar.gz -C $(libwesteros_sink_IPK_TMP_DIR) usr
+	tar -czvf $(libwesteros_sink_IPK_OUTDIR)/control.tar.gz -C $(libwesteros_sink_IPK_OUTDIR) $(libwesteros_sink_CONTROL_FILES)
+	cd $(libwesteros_sink_IPK_OUTDIR) && ar cr $(libwesteros_sink_IPK_OUTPUT) $(libwesteros_sink_IPK_FILES) && cd -
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff --git a/syna/westeros-sink/configure.ac b/syna/westeros-sink/configure.ac
new file mode 100644
index 0000000..ee144b9
--- /dev/null
+++ b/syna/westeros-sink/configure.ac
@@ -0,0 +1,98 @@
+#
+# If not stated otherwise in this file or this component's Licenses.txt file the
+# following copyright and licenses apply:
+#
+# Copyright 2016 RDK Management
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+#                                               -*- Autoconf -*-
+# Process this file with autoconf to produce a configure script.
+
+dnl AC_PREREQ([2.65])
+AC_INIT(westeros-sink, version-1.0, jeff_wannamaker@cable.comcast.com,westeros-sink)
+AC_CONFIG_SRCDIR([])
+AC_CONFIG_HEADERS([cfg/config.h])
+AC_CONFIG_MACRO_DIR([cfg])
+AC_CONFIG_AUX_DIR([cfg])
+AM_INIT_AUTOMAKE([foreign no-dist-gzip dist-bzip2 1.9])
+LT_INIT
+
+# Checks for programs.
+AC_PROG_CC
+AC_PROG_INSTALL
+AC_PROG_MAKE_SET
+AC_PROG_CXX
+
+# Checks for header files.
+AC_CHECK_HEADERS([stdlib.h string.h unistd.h])
+
+# Checks for typedefs, structures, and compiler characteristics.
+AC_TYPE_SIZE_T
+AC_HEADER_STDBOOL
+
+IARM_CFLAGS=" "
+
+# Checks for library functions.
+#Add the subdirectories to be considered for building.
+SUBDIRS=" "
+#to setup m4 macros
+m4_ifdef([AM_SILENT_RULES],[AM_SILENT_RULES([yes])],
+[AM_DEFAULT_VERBOSITY=1
+AC_SUBST(AM_DEFAULT_VERBOSITY)])
+
+dnl GStreamer version. Use 0.10 by default
+AC_ARG_ENABLE(gstreamer1,
+              AS_HELP_STRING([--enable-gstreamer1],
+                             [Use GStreamer 1.x]), ,
+              [enable_gstreamer1=auto])
+
+AS_IF([test "x$enable_gstreamer1" = "xyes"], [
+  GST_MAJORMINOR=1.0
+  PKG_CHECK_MODULES([GST], [gstreamer-1.0 >= 1.4], have_gst1="yes", have_gst1="no")
+
+  AS_IF([test "x$have_gst1" = "xyes"], [
+    PKG_CHECK_MODULES([GSTBASE], [gstreamer-base-1.0 >= 1.4])
+    AC_DEFINE(USE_GST1, 1, [Build with GStreamer 1.x])
+  ], [])
+], [])
+
+AS_IF([test "x$enable_gstreamer1" = "xyes" -a "x$have_gst1" != "xyes"], [
+   AC_MSG_ERROR([Could not find GStreamer 1.x dependencies:
+
+$GST_PKG_ERRORS])], [])
+
+AS_IF([test "x$have_gst1" != "xyes"], [
+  GST_MAJORMINOR=0.10
+  PKG_CHECK_MODULES([GST], [gstreamer-0.10 >= 0.10.28])
+  PKG_CHECK_MODULES([GSTBASE], [gstreamer-base-0.10 >= 0.10.28])
+], [])
+
+plugindir="\$(libdir)/gstreamer-$GST_MAJORMINOR"
+
+PKG_CHECK_MODULES([GLIB],[glib-2.0 >= 2.22.5])
+PKG_CHECK_MODULES([GTHREAD],[gthread-2.0 >= 2.38.2])
+PKG_CHECK_MODULES([WAYLAND_CLIENT],[wayland-client >= 1.6.0])
+PKG_CHECK_MODULES([WAYLAND_SERVER],[wayland-server >= 1.6.0])
+
+WAYLANDLIB="-lwayland-client"
+AC_SUBST(WAYLANDLIB)
+
+AC_CONFIG_FILES([Makefile])
+AC_SUBST(WAYLAND_CFLAGS)
+AC_SUBST(GUPNP_VERSION)
+AC_SUBST(GST_MAJORMINOR)
+AC_SUBST(plugindir)
+AC_OUTPUT
+
diff --git a/syna/westeros-sink/mpegstreaminfo.h b/syna/westeros-sink/mpegstreaminfo.h
new file mode 100644
index 0000000..43fee77
--- /dev/null
+++ b/syna/westeros-sink/mpegstreaminfo.h
@@ -0,0 +1,66 @@
+/*******************************************************************************/
+/* Copyright 2012, MARVELL SEMICONDUCTOR, LTD. */
+/* THIS CODE CONTAINS CONFIDENTIAL INFORMATION OF MARVELL. */
+/* NO RIGHTS ARE GRANTED HEREIN UNDER ANY PATENT, MASK WORK RIGHT OR COPYRIGHT */
+/* OF MARVELL OR ANY THIRD PARTY. MARVELL RESERVES THE RIGHT AT ITS SOLE */
+/* DISCRETION TO REQUEST THAT THIS CODE BE IMMEDIATELY RETURNED TO MARVELL. */
+/* THIS CODE IS PROVIDED "AS IS". MARVELL MAKES NO WARRANTIES, EXPRESSED,*/
+/* IMPLIED OR OTHERWISE, REGARDING ITS ACCURACY, COMPLETENESS OR PERFORMANCE. */
+/* MARVELL COMPRISES MARVELL TECHNOLOGY GROUP LTD. (MTGL) AND ITS SUBSIDIARIES, */
+/* MARVELL INTERNATIONAL LTD. (MIL), MARVELL TECHNOLOGY, INC. (MTI), MARVELL */
+/* SEMICONDUCTOR, INC. (MSI), MARVELL ASIA PTE LTD. (MAPL), MARVELL JAPAN K.K. */
+/* (MJKK), MARVELL ISRAEL LTD. (MSIL).*/
+/*******************************************************************************/
+
+#ifndef __MPEG_STREAM_INFO_H__
+#define __MPEG_STREAM_INFO_H__
+
+#include <gst/gst.h>
+#include <config.h>
+
+
+G_BEGIN_DECLS
+
+/*MPEG-2 TS Media types*/
+enum
+{
+	VIDEO_MPEG1                             = 1,
+	VIDEO_MPEG2                             = 2,
+	AUDIO_MPEG1                             = 3,
+	AUDIO_MPEG2                             = 4,
+	AUDIO_AAC                               = 15,
+	VIDEO_H264                              = 27,
+	VIDEO_MPEG_DCII                         = 128,
+	AUDIO_AC3                               = 129,
+	VIDEO_HEVC                              = 36,
+};
+typedef struct PmtStreamInfoClass {
+	GObjectClass parent_class;
+} PmtStreamInfoClass;
+
+typedef struct PmtStreamInfo {
+	GObject parent;
+
+	GValueArray *languages;
+	guint16 pid;
+	GValueArray *descriptors;
+	guint8 stream_type;
+} PmtStreamInfo;
+
+PmtStreamInfo *pmt_stream_info_new (guint16 pid, guint8 type);
+void pmt_stream_info_add_language(PmtStreamInfo* si,
+		gchar* language);
+void pmt_stream_info_add_descriptor (PmtStreamInfo *pmt_info,
+		const gchar *descriptor, guint length);
+
+GType pmt_stream_info_get_type (void);
+
+#define TYPE_PMT_STREAM_INFO (pmt_stream_info_get_type ())
+
+#define IS_PMT_STREAM_INFO(obj) (G_TYPE_CHECK_INSTANCE_TYPE((obj), TYPE_PMT_STREAM_INFO))
+#define PMT_STREAM_INFO(obj) (G_TYPE_CHECK_INSTANCE_CAST((obj),TYPE_PMT_STREAM_INFO, PmtStreamInfo))
+
+G_END_DECLS
+
+#endif
+
diff --git a/syna/westeros-sink/westeros-sink-soc.c b/syna/westeros-sink/westeros-sink-soc.c
new file mode 100644
index 0000000..130a1a7
--- /dev/null
+++ b/syna/westeros-sink/westeros-sink-soc.c
@@ -0,0 +1,2603 @@
+/*
+ * If not stated otherwise in this file or this component's Licenses.txt file the
+ * following copyright and licenses apply:
+ *
+ * Copyright 2016 RDK Management
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <string.h>
+#include <stdio.h>
+#include <sys/time.h>
+
+#include "westeros-sink.h"
+
+#define FRAME_POLL_TIME (8000)
+#define EOS_DETECT_DELAY (500000)
+#define EOS_DETECT_DELAY_AT_START (10000000)
+
+#define MAX_VIDEO_STREAM_SIZE (256)
+#define VIDEO_ES_BUFFER_SIZE  (4 * 1024 * 1024)
+
+GST_DEBUG_CATEGORY_EXTERN (gst_westeros_sink_debug);
+#define GST_CAT_DEFAULT gst_westeros_sink_debug
+
+#define VERIFY_RESULT(x) \
+        do {\
+               if ((x) != SUCCESS)\
+                   GST_ERROR("error=%x, (%s)@%d\n",\
+                                x, __FUNCTION__, __LINE__);\
+        } while(0)
+
+typedef enum {
+	NO_LINEAR, //No linear space
+	LINEAR_END,//Linear space at the end of buffer
+	LINEAR_BEG,//Linear space at the beginning of buffer
+}LINEAR_POS;
+
+typedef enum
+{
+  FEED_DONE,
+  FEED_RETRY,
+  FEED_ERR,
+}FEED_RET;
+
+static gboolean amp_handle_event_caps(Gstampvsink* amp_sink, GstCaps* caps);
+static HRESULT amp_sink_set_state(Gstampvsink* amp_sink, AMP_STATE state);
+static HRESULT amp_disconnect(Gstampvsink *amp_sink);
+static void amp_vout_destroy(Gstampvsink* amp_sink);
+static HRESULT amp_vdec_destroy(Gstampvsink *amp_sink);
+static GstFlowReturn gst_amp_vdec_chain (GstPad * pad, GstObject * parent, GstBuffer * buf);
+static void waiting_for_BD_reset_buf(Gstampvsink* amp_sink);
+static gpointer vsink_feed_task(gpointer data);
+
+static void feed_thread_init(Gstampvsink *amp_sink);
+static void feed_thread_stop(Gstampvsink *amp_sink);
+static void feed_thread_push(Gstampvsink *amp_sink, GstBuffer* buf);
+static void feed_thread_destroy(Gstampvsink *amp_sink);
+
+
+/*######################################################################*/
+
+/* amp_sink signals and args */
+enum
+{
+        PROP_TV_MODE = PROP_SOC_BASE,
+        PROP_PLANE,
+        PROP_RECTANGLE,
+        PROP_FLUSH_REPEAT_FRAME,
+        PROP_CURRENT_PTS,
+        PROP_INTER_FRAME_DELAY,
+        PROP_SLOW_MODE_RATE,
+        PROP_CONTENT_FRAME_RATE,
+        PROP_STEP_FRAME,
+        PROP_MUTE,
+        PROP_ZOOM,
+        PROP_PLAY_SPEED,
+        PROP_VOUT
+};
+
+static AMP_FACTORY hFactory = NULL;
+#define GST_AMP_TV_MODE (gst_tv_mode_get_type())
+static GType gst_tv_mode_get_type (void)
+{
+
+        static GType ampamp_sink_tvmode_type = 0;
+
+        if (!ampamp_sink_tvmode_type) {
+                static const GEnumValue ampamp_sink_tvmode[] = {
+
+            {DISP_OUT_RES_NTSC_M, "480 interlaced at 60 Hz", "0"},
+            {DISP_OUT_RES_480P60, "480 progressive at 60 Hz", "1"},
+            {DISP_OUT_RES_PAL_M, "576 interlaced at 50 Hz", "2"},
+            {DISP_OUT_RES_PAL_BGH, "576 progressive at 50 Hz", "3"},
+            {DISP_OUT_RES_720P60, "720 progressive at 60 Hz", "4"},
+            {DISP_OUT_RES_720P50, "720 progressive at 50 Hz", "5"},
+            {DISP_OUT_RES_1080I60, "1080 interlaced at 60 Hz", "6"},
+            {DISP_OUT_RES_1080I50, "1080 interlaced at 50 Hz", "7"},
+            {DISP_OUT_RES_1080P60, "1080 progressive at 60 Hz", "8"},
+            {DISP_OUT_RES_1080P50, "1080 progressive at 50 Hz", "9"},
+            {0, NULL, NULL}
+
+                };
+
+                ampamp_sink_tvmode_type =
+                        g_enum_register_static ("GstAmpSinkTvMode",ampamp_sink_tvmode);
+        }
+
+        return ampamp_sink_tvmode_type;
+}
+
+#define GST_AMP_PLANE (gst_plane_get_type())
+static GType gst_plane_get_type (void)
+{
+        static GType ampamp_sink_plane_type = 0;
+
+        if (!ampamp_sink_plane_type) {
+                static const GEnumValue ampamp_sink_planes[] = {
+                        {AMP_DISP_PLANE_MAIN, "plane main", "0"},
+                        {AMP_DISP_PLANE_PIP, "plane pip", "1"},
+                        {AMP_DISP_PLANE_GFX0, "plane gfx0", "2"},
+                        {AMP_DISP_PLANE_GFX1, "plane gfx1", "3"},
+                        {AMP_DISP_PLANE_GFX2, "palne gfx2", "4"},
+                        {AMP_DISP_PLANE_PG, "plane pg", "5"},
+                        {AMP_DISP_PLANE_BG, "plane bg", "6"},
+                        {AMP_DISP_PLANE_AUX, "plane aux", "7"},
+                        {AMP_DISP_PLANE_MAX, "plane max", "8"},
+                        {0, NULL, NULL},
+                };
+
+                ampamp_sink_plane_type =
+                        g_enum_register_static ("GstAmpSinkPlane",ampamp_sink_planes);
+        }
+
+        return ampamp_sink_plane_type;
+
+}
+
+/* Description for Element Pads */
+static GstStaticPadTemplate sink_amp_sink_pad = GST_STATIC_PAD_TEMPLATE ("sink",
+    GST_PAD_SINK,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS ("video/x-h264;"
+        "video/x-h265;"
+        "video/x-vp9;"
+        "video/x-vp8;"
+       )
+    );
+
+/**
+ * Sink pad event handler funtion
+ */
+static gboolean gst_amp_sink_event (GstPad *pad, GstObject * objectParent, GstEvent *event)
+{
+    GstWesterosSink  *sink = GST_WESTEROS_SINK(objectParent);
+    Gstampvsink *amp_sink = &sink->soc.amp_sink;
+    GstElement *element = GST_ELEMENT(sink);
+    HRESULT result = SUCCESS;
+    GstStructure *structureConComp;
+
+    if(GST_EVENT_TYPE (event) != GST_EVENT_TAG)
+        GST_DEBUG_OBJECT (sink, "Received %s event: %" GST_PTR_FORMAT,
+                GST_EVENT_TYPE_NAME (event), event);
+
+    switch (GST_EVENT_TYPE (event)) {
+    case GST_EVENT_CAPS:
+    {
+        GstCaps *caps;
+        gst_event_parse_caps (event, &caps);
+        GST_LOG_OBJECT (sink, "receive caps %" GST_PTR_FORMAT, caps);
+        gboolean handled = amp_handle_event_caps(amp_sink, caps);
+        if(handled) {
+            if(amp_sink->cap_accepted == NULL)
+                amp_sink->cap_accepted = gst_caps_copy(caps);
+            else if(!gst_caps_is_equal(amp_sink->cap_accepted, caps)) {
+                gst_caps_unref(amp_sink->cap_accepted);
+                amp_sink->cap_accepted = gst_caps_copy(caps);
+            }
+        }
+        break;
+    }
+    case GST_EVENT_EOS:
+    {
+        gst_westeros_sink_soc_eos_event( sink );
+        break;
+    }
+    case GST_EVENT_FLUSH_START:
+    {
+        feed_thread_stop(amp_sink);
+        result = amp_sink_set_state(amp_sink, AMP_IDLE);
+        VERIFY_RESULT(result);
+        if(amp_sink->hVdec) {
+            AMP_RPC(result, AMP_VDEC_ClearPortBuf, amp_sink->hVdec, AMP_PORT_OUTPUT, 0);
+            VERIFY_RESULT(result);
+            AMP_RPC(result, AMP_VDEC_ClearPortBuf, amp_sink->hVdec, AMP_PORT_INPUT, 0);
+            VERIFY_RESULT(result);
+        }
+        if(amp_sink->hVout) {
+            AMP_RPC(result, AMP_VOUT_ClearPortBuf, amp_sink->hVout, AMP_PORT_INPUT, 0);
+            VERIFY_RESULT(result);
+        }
+        //gst_element_set_base_time(element, GST_CLOCK_TIME_NONE);
+        gst_westeros_sink_soc_flush( sink );
+        break;
+    }
+    case GST_EVENT_FLUSH_STOP:
+    {
+        GST_PAD_STREAM_LOCK(amp_sink->sinkpad);
+        feed_thread_destroy(amp_sink);
+        feed_thread_init(amp_sink);
+        waiting_for_BD_reset_buf(amp_sink);
+        result = amp_sink_set_state(amp_sink, AMP_EXECUTING);
+        VERIFY_RESULT(result);
+        GST_PAD_STREAM_UNLOCK(amp_sink->sinkpad);
+        break;
+    }
+    case GST_EVENT_SEGMENT:
+    {
+        const GstStructure *event_structure = gst_event_get_structure(event);
+        GstSegment *segment;
+        const GValue *durVal = gst_structure_get_value(event_structure,"segment");
+        segment = (GstSegment *)g_value_peek_pointer(durVal);
+        if(segment->stop != -1){
+            GST_DEBUG_OBJECT(sink, "###duration = %" GST_TIME_FORMAT,
+                    GST_TIME_ARGS(segment->stop - segment->start));
+            amp_sink->stream_duration = segment->stop - segment->start;
+            amp_sink->current_time = segment->start;
+        }else if(segment->duration != -1){
+            GST_DEBUG_OBJECT(sink, "###duration = %" GST_TIME_FORMAT,
+                    GST_TIME_ARGS(segment->duration));
+            amp_sink->stream_duration = segment->duration;
+        }else{
+            GST_WARNING("###duration is not present in segment event\n");
+        }
+
+        gst_westeros_sink_soc_set_startPTS( sink, segment->start);
+        break;
+    }
+    default:
+        break;
+    }
+
+    return GST_WESTEROS_SINK_GET_CLASS(sink)->sink_cb(pad, objectParent,event);
+}
+
+/*######################################################################*/
+
+static gboolean gst_ampvsink_sink_query_function (GstElement *element,GstQuery *query) {
+  gboolean ret = FALSE;
+  GstFormat format=GST_FORMAT_TIME;
+  HRESULT result = SUCCESS;
+  UINT32 ptsHigh, ptsLow;
+
+  GstWesterosSink *sink = GST_WESTEROS_SINK(element);
+  Gstampvsink *amp_sink = &sink->soc.amp_sink;
+
+  switch(GST_QUERY_TYPE(query)){
+    case GST_QUERY_POSITION:
+    {
+        GstFormat format;
+        gst_query_parse_position(query, &format, NULL);
+        if(format == GST_FORMAT_TIME) {
+            gint64 time = amp_sink->current_time;
+            gst_query_set_position (query, format, time);
+            ret = TRUE;
+        }
+        break;
+    }
+    case GST_QUERY_DURATION:
+    {
+        GstFormat format;
+        gst_query_parse_duration(query,&format, NULL);
+        if(format == GST_FORMAT_TIME) {
+            if(amp_sink->stream_duration) {
+                gst_query_set_duration (query, format, amp_sink->stream_duration);
+                ret = TRUE;
+            } else {
+                if(gst_pad_peer_query_duration(amp_sink->sinkpad, format,
+                            &amp_sink->stream_duration)) {
+                    gst_query_set_duration (query, format, amp_sink->stream_duration);
+                    ret = TRUE;
+                }
+            }
+        }
+        break;
+    }
+    case GST_QUERY_SEEKING:
+    {
+        ret = gst_pad_peer_query(amp_sink->sinkpad, query);
+        break;
+    }
+    default:
+    {
+        ret = FALSE;
+        break;
+    }
+  }
+
+  return ret;
+}
+
+static HRESULT amp_sink_set_state(Gstampvsink* amp_sink, AMP_STATE state) {
+    HRESULT result;
+    if(amp_sink->hVdec && amp_sink->pipeline_created){
+        AMP_RPC(result, AMP_VDEC_SetState, amp_sink->hVdec, state);
+        VERIFY_RESULT(result);
+    }
+    if(amp_sink->hVout){
+        AMP_RPC(result, AMP_VOUT_SetState, amp_sink->hVout, state);
+        VERIFY_RESULT(result);
+    }
+    if(amp_sink->hClk){
+        AMP_RPC(result, AMP_CLK_SetState, amp_sink->hClk, state);
+        VERIFY_RESULT(result);
+    }
+    return result;
+}
+
+/**
+ * To destroy AMP Vout Component
+ */
+
+static HRESULT amp_sink_destroy(Gstampvsink *amp_sink) {
+    HRESULT result = SUCCESS;
+
+    if(amp_sink->Disp) {
+        /* restore Z-orver */
+        AMP_RPC(result,
+                AMP_DISP_SetPlaneZOrder,
+                amp_sink->Disp,
+                0,
+                &amp_sink->Zorder);
+        VERIFY_RESULT(result);
+    }
+
+    amp_vout_destroy(amp_sink);
+    amp_vdec_destroy(amp_sink);
+    return result;
+}
+
+/**
+ *  Function to handle EOS flag from VOUT
+ */
+static HRESULT amp_sink_event_handler(HANDLE hListener, AMP_EVENT * pEvent,
+    VOID * pUserData)
+{
+    HRESULT result = SUCCESS;
+    AMP_STATE eState;
+    Gstampvsink *amp_sink = (Gstampvsink*)pUserData;
+
+    if (pEvent->stEventHead.eEventCode == AMP_EVENT_API_VOUT_CALLBACK) {
+        GST_DEBUG("VOUT Received EOS");
+        amp_sink->is_eos = true;
+        if(gst_element_post_message(GST_ELEMENT(amp_sink->westeros_sink),
+                    gst_message_new_eos(GST_OBJECT(amp_sink->westeros_sink))))
+            GST_DEBUG(" EOS message posted to application ");
+    } else if (pEvent->stEventHead.eEventCode ==
+            AMP_EVENT_API_VOUT_CALLBACK_FIRST_FRAME) {
+        GST_DEBUG("  Received First Frame Event from  AMP Vout Component ");
+    } else if (pEvent->stEventHead.eEventCode ==
+            AMP_EVENT_API_VOUT_CALLBACK_FRAME_UPDATE) {
+        AMP_VOUT_DISP_FRAME_INFO *pFrame =
+            (AMP_VOUT_DISP_FRAME_INFO *) AMP_EVENT_PAYLOAD_PTR(pEvent);
+        GST_LOG("amp_sink pts: :%x dis:%d\n", pFrame->pts_l, pFrame->displayed);
+        if(!pFrame->displayed)
+            GST_LOG("frame dropped pts: %x:%x\n", pFrame->pts_h, pFrame->pts_l);
+
+        amp_sink->current_time = (gint64)((UINT64)AMP_GET_PTS_VAL(
+                    AMP_MAKE_PTS64(pFrame->pts_h, pFrame->pts_l)) * 100000 / 9);
+    }
+    return result;
+}
+
+/**
+ *  Function to register event callback to VOUT for EOS
+ */
+static HRESULT amp_vout_event_register(Gstampvsink *amp_sink)
+{
+  HRESULT result;
+
+  amp_sink->hVListener = AMP_Event_CreateListener(AMP_EVENT_TYPE_MAX, 0);
+
+  result = AMP_Event_RegisterCallback(amp_sink->hVListener,
+      AMP_EVENT_API_VOUT_CALLBACK,
+      amp_sink_event_handler, amp_sink);
+  VERIFY_RESULT(result);
+  AMP_RPC(result, AMP_VOUT_RegisterNotify, amp_sink->hVout,
+          AMP_Event_GetServiceID(amp_sink->hVListener), AMP_EVENT_API_VOUT_CALLBACK);
+  VERIFY_RESULT(result);
+  result = AMP_Event_RegisterCallback(amp_sink->hVListener,
+      AMP_EVENT_API_VOUT_CALLBACK_FIRST_FRAME,
+      amp_sink_event_handler, amp_sink);
+  VERIFY_RESULT(result);
+  AMP_RPC(result, AMP_VOUT_RegisterNotify, amp_sink->hVout,
+          AMP_Event_GetServiceID(amp_sink->hVListener), AMP_EVENT_API_VOUT_CALLBACK_FIRST_FRAME);
+  VERIFY_RESULT(result);
+  result = AMP_Event_RegisterCallback(amp_sink->hVListener,
+      AMP_EVENT_API_VOUT_CALLBACK_FRAME_UPDATE,
+      amp_sink_event_handler, amp_sink);
+  VERIFY_RESULT(result);
+  AMP_RPC(result, AMP_VOUT_RegisterNotify, amp_sink->hVout,
+          AMP_Event_GetServiceID(amp_sink->hVListener), AMP_EVENT_API_VOUT_CALLBACK_FRAME_UPDATE);
+  VERIFY_RESULT(result);
+  return result;
+}
+
+/**
+ * To unregister VOUT Notification
+ */
+
+static HRESULT amp_vout_unregister(Gstampvsink *amp_sink) {
+  HRESULT result = S_OK;
+  /**
+   * Unregister the notification
+   */
+  AMP_RPC(result, AMP_VOUT_UnregisterNotify,amp_sink->hVout,
+      AMP_Event_GetServiceID(amp_sink->hVListener), AMP_EVENT_API_VOUT_CALLBACK);
+  VERIFY_RESULT(result);
+
+  result = AMP_Event_UnregisterCallback(amp_sink->hVListener,
+      AMP_EVENT_API_VOUT_CALLBACK,
+      amp_sink_event_handler);
+  VERIFY_RESULT(result);
+
+  AMP_RPC(result, AMP_VOUT_UnregisterNotify,amp_sink->hVout,
+      AMP_Event_GetServiceID(amp_sink->hVListener),
+      AMP_EVENT_API_VOUT_CALLBACK_FIRST_FRAME);
+  VERIFY_RESULT(result);
+
+  result = AMP_Event_UnregisterCallback(amp_sink->hVListener,
+      AMP_EVENT_API_VOUT_CALLBACK_FIRST_FRAME,
+      amp_sink_event_handler);
+  VERIFY_RESULT(result);
+
+  AMP_RPC(result, AMP_VOUT_UnregisterNotify,amp_sink->hVout,
+      AMP_Event_GetServiceID(amp_sink->hVListener),
+      AMP_EVENT_API_VOUT_CALLBACK_FRAME_UPDATE);
+  VERIFY_RESULT(result);
+
+  result = AMP_Event_UnregisterCallback(amp_sink->hVListener,
+      AMP_EVENT_API_VOUT_CALLBACK_FRAME_UPDATE,
+      amp_sink_event_handler);
+  VERIFY_RESULT(result);
+
+  result = AMP_Event_DestroyListener(amp_sink->hVListener);
+  amp_sink->hVListener = NULL;
+  VERIFY_RESULT(result);
+  return result;
+}
+
+static HRESULT amp_disp_open(Gstampvsink* amp_sink) {
+    HRESULT result = S_OK;
+    UINT32 resId = 0;
+    /* display service */
+    AMP_RPC(result, AMP_FACTORY_CreateDisplayService,
+            hFactory, &(amp_sink->Disp));
+    VERIFY_RESULT(result);
+    /* check if current display is set at 4k */
+    AMP_RPC(result,
+            AMP_DISP_OUT_GetResolution,
+            amp_sink->Disp,
+            AMP_DISP_PLANE_MAIN,
+            &resId);
+    VERIFY_RESULT(result);
+    if((resId >= AMP_DISP_OUT_RES_4Kx2K_MIN) &&
+            (resId < AMP_DISP_OUT_RES_4Kx2K_MAX)) {
+        /* scale the video rectangle window for 4k*/
+        amp_sink->DstWin.iX *= 2;
+        amp_sink->DstWin.iY *= 2;
+        amp_sink->DstWin.iWidth *= 2;
+        amp_sink->DstWin.iHeight *= 2;
+    }
+
+    /* set scale */
+    AMP_RPC(result, AMP_DISP_SetScale, amp_sink->Disp,
+            0, &amp_sink->SrcWin, &amp_sink->DstWin);
+
+    /* Z order Main is below GFX plane */
+    AMP_RPC(result,
+            AMP_DISP_GetPlaneZOrder,
+            amp_sink->Disp,
+            0,
+            &amp_sink->Zorder);
+    VERIFY_RESULT(result);
+
+    amp_sink->Zorder.iMain = 2;
+    amp_sink->Zorder.iPip  = 6;
+    amp_sink->Zorder.iGfx0 = 5;
+    amp_sink->Zorder.iGfx1 = 4;
+    amp_sink->Zorder.iGfx2 = 3;
+    amp_sink->Zorder.iPg   = 1;
+    amp_sink->Zorder.iBg   = 0;
+    amp_sink->Zorder.iAux  = -1;
+    AMP_RPC(result, AMP_DISP_SetPlaneZOrder, amp_sink->Disp, 0, &amp_sink->Zorder);
+    VERIFY_RESULT(result);
+
+    if(amp_sink->is_zoomSet) {
+        if (1 == amp_sink->zoom) {
+            if( amp_sink->resolution == 2160 ) {
+                amp_sink->SrcWin.iX=0;
+                amp_sink->SrcWin.iY=0;
+                amp_sink->SrcWin.iWidth=0;
+                amp_sink->SrcWin.iHeight=0;
+
+                amp_sink->DstWin.iX=0;
+                amp_sink->DstWin.iY=0;
+                amp_sink->DstWin.iWidth=3840;
+                amp_sink->DstWin.iHeight=2160;
+            } else if( amp_sink->resolution == 1080 ) {
+                amp_sink->SrcWin.iX=0;
+                amp_sink->SrcWin.iY=0;
+                amp_sink->SrcWin.iWidth=0;
+                amp_sink->SrcWin.iHeight=0;
+
+                amp_sink->DstWin.iX=0;
+                amp_sink->DstWin.iY=0;
+                amp_sink->DstWin.iWidth=1920;
+                amp_sink->DstWin.iHeight=1080;
+            } else if( amp_sink->resolution == 720 ) {
+                amp_sink->SrcWin.iX=0;
+                amp_sink->SrcWin.iY=0;
+                amp_sink->SrcWin.iWidth=0;
+                amp_sink->SrcWin.iHeight=0;
+
+                amp_sink->DstWin.iX=0;
+                amp_sink->DstWin.iY=0;
+                amp_sink->DstWin.iWidth=1280;
+                amp_sink->DstWin.iHeight=720;
+            }
+        } else if(0 == amp_sink->zoom) {
+            amp_sink->SrcWin.iX=0;
+            amp_sink->SrcWin.iY=0;
+            amp_sink->SrcWin.iWidth=0;
+            amp_sink->SrcWin.iHeight=0;
+
+            amp_sink->DstWin.iX=0;
+            amp_sink->DstWin.iY=0;
+            amp_sink->DstWin.iWidth=0;
+            amp_sink->DstWin.iHeight=0;
+
+        }
+        AMP_RPC(result, AMP_DISP_SetScale, amp_sink->Disp,0, &amp_sink->SrcWin, &amp_sink->DstWin);
+        VERIFY_RESULT(result);
+        amp_sink->is_zoomSet=false;
+    }
+    return result;
+}
+
+static HRESULT amp_vout_open(Gstampvsink* amp_sink) {
+    HRESULT result;
+    int cnt = 0;
+    UINT32 resId = 0;
+    AMP_COMPONENT_CONFIG config;
+
+    AmpMemClear(&config, sizeof (AMP_COMPONENT_CONFIG));
+    config._d = AMP_COMPONENT_VOUT;
+    config._u.pVOUT.mode = AMP_TUNNEL;
+    config._u.pVOUT.uiPlaneID = AMP_DISP_PLANE_MAIN;
+    config._u.pVOUT.uiInputPortNum = 2;
+    config._u.pVOUT.uiOutputPortNum = 0;
+
+    AMP_RPC(result, AMP_VOUT_Open, amp_sink->hVout, &config);
+    VERIFY_RESULT(result);
+
+    result = amp_vout_event_register(amp_sink);
+    VERIFY_RESULT(result);
+    amp_sink->is_eos = false;
+
+    AMP_RPC(result,
+            AMP_VOUT_SetLastFrameMode,
+            amp_sink->hVout,
+            AMP_VOUT_REPEATLASTFRAME);
+    VERIFY_RESULT(result);
+
+    return result;
+}
+
+static HRESULT amp_vout_close(Gstampvsink* amp_sink) {
+    HRESULT result = SUCCESS;
+    if(amp_sink->hVout) {
+        amp_vout_unregister(amp_sink);
+        AMP_RPC(result, AMP_VOUT_Close,amp_sink->hVout);
+        VERIFY_RESULT(result);
+    }
+    return result;
+}
+
+static void amp_vout_destroy(Gstampvsink* amp_sink) {
+    if(amp_sink->hVout) {
+        HRESULT result;
+        AMP_RPC(result, AMP_VOUT_Destroy,amp_sink->hVout);
+        VERIFY_RESULT(result);
+        amp_sink->hVout = NULL;
+    }
+}
+
+static HRESULT amp_vdec_callback(CORBA_Object hCompObj,
+        AMP_PORT_IO ePortIo,
+        UINT32 uiPortIdx,
+        struct AMP_BD_ST *hBD,
+        AMP_IN void *pUserData)
+{
+
+    HRESULT ret;
+    Gstampvsink *amp_sink = (Gstampvsink*)pUserData;
+    AMP_BDTAG_MEMINFO *mem_info = NULL;
+
+    if (ePortIo == AMP_PORT_INPUT) {
+        ret = AMP_BDTAG_GetWithType(hBD,AMP_BDTAG_ASSOCIATE_MEM_INFO, NULL, (void**)&mem_info);
+        VERIFY_RESULT(ret);
+        if(!amp_sink->secure) {
+            amp_sink->rp_v = (mem_info->uMemOffset + mem_info->uSize);
+        } else {
+            /* release SHM allocated by decryptor */
+            AMP_SHM_Unref(mem_info->uMemHandle);
+        }
+
+        GST_LOG("vdec receive BD:%d ro:%x\n", AMP_BD_GET_BDID(hBD), amp_sink->rp_v);
+        ret = AMP_BDCHAIN_PushItem(amp_sink->video_stream_queue, hBD);
+        VERIFY_RESULT(ret);
+    }
+    return SUCCESS;
+}
+
+static HRESULT amp_vdec_event_callback(HANDLE hListener, AMP_EVENT *pEvent,
+        VOID *pUserData)
+{
+    UINT32 *payload = (UINT32*)AMP_EVENT_PAYLOAD_PTR(pEvent);
+    switch (AMP_EVENT_GETCODE(*pEvent)) {
+        case AMP_EVENT_API_VDEC_CALLBACK: {
+            switch (AMP_EVENT_GETPAR1(*pEvent)) {
+            case AMP_VDEC_EVENT_RES_CHANGE:
+                GST_INFO("resolution changed width:%d height:%d\n", payload[0], payload[1]);
+                break;
+            case AMP_VDEC_EVENT_FR_CHANGE:
+                GST_DEBUG("frame rate changed numerator:%d denominator:%d\n",
+                        payload[0], payload[1]);
+                break;
+            case AMP_VDEC_EVENT_AR_CHANGE:
+                GST_DEBUG("aspect ratio changed width:%d height:%d\n", payload[0], payload[1]);
+                break;
+            case AMP_VDEC_EVENT_DISP_CROP_CHANGE:
+                break;
+            default:
+                break;
+            }
+            break;
+        }
+        default:
+            break;
+    }
+    return SUCCESS;
+}
+
+static HRESULT amp_vdec_open(Gstampvsink *amp_sink)
+{
+    HRESULT ret;
+    AMP_COMPONENT_CONFIG config;
+
+    AmpMemClear(&config, sizeof(AMP_COMPONENT_CONFIG));
+    config._d = AMP_COMPONENT_VDEC;
+    config._u.pVDEC.mode = AMP_SECURE_TUNNEL;
+    config._u.pVDEC.uiType = amp_sink->video_codec;
+    config._u.pVDEC.uiFlag |= AMP_VDEC_MODE_FRAME_IN;
+
+    AMP_RPC(ret, AMP_VDEC_Open, amp_sink->hVdec, &config);
+    VERIFY_RESULT(ret);
+
+    ret = AMP_ConnectApp(amp_sink->hVdec,
+            AMP_PORT_INPUT,
+            0,
+            amp_vdec_callback,
+            amp_sink);
+    VERIFY_RESULT(ret);
+
+    amp_sink->hVdecListener = AMP_Event_CreateListener(16, 0);
+
+    ret = AMP_Event_RegisterCallback(amp_sink->hVdecListener,
+            AMP_EVENT_API_VDEC_CALLBACK,
+            amp_vdec_event_callback,
+            amp_sink);
+    VERIFY_RESULT(ret);
+    AMP_RPC(ret, AMP_VDEC_RegisterNotify, amp_sink->hVdec,
+            AMP_Event_GetServiceID(amp_sink->hVdecListener),
+            AMP_EVENT_API_VDEC_CALLBACK);
+    VERIFY_RESULT(ret);
+
+    return ret;
+}
+
+static HRESULT amp_vdec_destroy(Gstampvsink *amp_sink)
+{
+    HRESULT ret = SUCCESS;
+    GST_DEBUG("Destroy Vdec");
+    if (amp_sink->hVdec) {
+        AMP_RPC(ret, AMP_COMPONENT_Destroy,amp_sink->hVdec);
+        VERIFY_RESULT(ret);
+        amp_sink->hVdec = NULL;
+    }
+    return ret;
+}
+
+static HRESULT amp_vdec_close(Gstampvsink *amp_sink)
+{
+    HRESULT ret = SUCCESS;
+
+    GST_DEBUG("Close Vdec");
+    if (amp_sink->hVdec) {
+        AMP_RPC(ret, AMP_VDEC_UnregisterNotify, amp_sink->hVdec,
+                AMP_Event_GetServiceID(amp_sink->hVdecListener),
+                AMP_EVENT_API_VDEC_CALLBACK);
+        VERIFY_RESULT(ret);
+
+        AMP_Event_UnregisterCallback(amp_sink->hVdecListener,
+                AMP_EVENT_API_VDEC_CALLBACK, amp_vdec_event_callback);
+        AMP_Event_DestroyListener(amp_sink->hVdecListener);
+        amp_sink->hVdecListener = NULL;
+
+        ret = AMP_DisconnectApp(amp_sink->hVdec, AMP_PORT_INPUT,
+                0, amp_vdec_callback);
+        VERIFY_RESULT(ret);
+
+        AMP_RPC(ret, AMP_VDEC_Close,amp_sink->hVdec);
+        VERIFY_RESULT(ret);
+    }
+    return ret;
+}
+
+static HRESULT amp_connect(Gstampvsink *amp_sink)
+{
+    HRESULT ret;
+    GST_DEBUG_OBJECT(amp_sink, "connect vdec to vout");
+    ret = AMP_ConnectComp(amp_sink->hVdec, 0, amp_sink->hVout, 0);
+    VERIFY_RESULT(ret);
+    GST_DEBUG_OBJECT(amp_sink, "connect clk to vout");
+    ret = AMP_ConnectComp(amp_sink->hClk, 0, amp_sink->hVout, 1);
+    VERIFY_RESULT(ret);
+    return ret;
+}
+
+static HRESULT amp_disconnect(Gstampvsink *amp_sink)
+{
+    HRESULT ret;
+    GST_DEBUG_OBJECT(amp_sink, "disconnect vdec from vout");
+    ret = AMP_DisconnectComp(amp_sink->hVdec, 0, amp_sink->hVout, 0);
+    VERIFY_RESULT(ret);
+    GST_DEBUG_OBJECT(amp_sink, "disconnect clk from vout");
+    ret = AMP_DisconnectComp(amp_sink->hClk, 0, amp_sink->hVout, 1);
+    VERIFY_RESULT(ret);
+    return ret;
+}
+
+static int pre_process_h264(Gstampvsink * amp_sink)
+{
+    UINT8 nal_start_code[4] = {0x00, 0x00, 0x00, 0x01};
+    UINT8 *data = amp_sink->codec_data, *data_end = amp_sink->codec_data + amp_sink->codec_size;
+    UINT32 copied = 0, sps_nb = 0, pps_nb = 0;
+    UINT8 *priv = amp_sink->video_priv_data;
+
+    if (data + 6 <= data_end) {
+        sps_nb = data[5] & 0x1f;
+        data += 6;
+    }
+
+    while (sps_nb--) {
+        UINT32 sps_len = 0;
+
+        if (data + 2 <= data_end) {
+            sps_len = data[0] << 8 | data[1];
+            data += 2;
+        }
+
+        if (sps_len && data + sps_len <= data_end) {
+            AmpMemcpy(priv + copied, nal_start_code, 4);
+            copied += 4;
+            AmpMemcpy(priv + copied, data, sps_len);
+            data += sps_len;
+            copied += sps_len;
+        }
+    }
+
+    if (copied) {
+        AmpMemSet(priv + copied, 0, 16);
+        copied += 16;
+    }
+
+    if (data + 1 <= data_end) {
+        pps_nb = *data;
+        data++;
+    }
+
+    while (pps_nb--) {
+        UINT32 pps_len = 0;
+
+        if (data + 2 <= data_end) {
+            pps_len = data[0] << 8 | data[1];
+            data += 2;
+        }
+
+        if (pps_len && data + pps_len <= data_end) {
+            AmpMemcpy(priv + copied, nal_start_code, 4);
+            copied += 4;
+            AmpMemcpy(priv + copied, data, pps_len);
+            data += pps_len;
+            copied += pps_len;
+        }
+    }
+    return copied;
+}
+
+//return code.
+//>0, data being copied
+//<0, fail
+static int post_process_h264(Gstampvsink *amp_sink, uint8_t *data, uint32_t size, uint8_t* dst, uint32_t dst_size){
+    if(size < 4){
+        GST_ERROR("data too short\n");
+        return -1;
+    }
+
+    if (data[0] == 0x00 && data[1] == 0x00 && data[2] == 0x00 && data[3] == 0x01){
+        //NAL starting code can be detected
+        if(dst_size >= size) {
+            memcpy(dst, data, size);
+            return size;
+        } else {
+            GST_ERROR("dst buffer too small\n");
+            return -1;
+        }
+    }
+
+    //Need to add NAL starting code.
+    uint8_t nal_start_code[4] = {0x00, 0x00, 0x00, 0x01};
+    uint8_t *src = data;
+    uint32_t rp = 0, wp = 0, nal_len_size = 4, nal_len;
+
+    if (amp_sink->codec_size > 3) {
+        nal_len_size = (amp_sink->codec_data[4] & 0x3) + 1;
+    }
+
+    while (rp < size) {
+        uint32_t n;
+        switch (nal_len_size) {
+            case 1:
+                nal_len = *src;
+                break;
+            case 2:
+                nal_len = src[rp] << 8 | src[rp + 1];
+                break;
+            case 3:
+                nal_len = src[rp] << 16 | src[rp + 1] << 8 |
+                    src[rp + 2];
+                break;
+            case 4:
+            default:
+                nal_len = src[rp] << 24 | src[rp + 1] << 16 |
+                    src[rp + 2] << 8 | src[rp + 3];
+                break;
+        }
+        if(wp + 4 < dst_size) {
+            memcpy(dst + wp, nal_start_code, 4);
+            rp += nal_len_size; wp += 4;
+        }else {
+            GST_ERROR("dst buffer too small\n");
+            return -1;
+        }
+
+        n = nal_len;
+        if(rp + n > size){
+            GST_ERROR("error, nal_len:%d > data left:%d\n", nal_len, size-rp);
+            n = size - rp;
+        }
+
+        if(wp + n > dst_size) {
+            GST_ERROR("dst buffer too small\n");
+            return -1;
+        }
+        memcpy(dst + wp, data + rp, n);
+        rp += n;
+        wp += n;
+    }
+
+    return wp;
+}
+
+static int pre_process_h265(Gstampvsink* amp_sink) {
+    UINT8 nal_start_code[4] = {0x00, 0x00, 0x00, 0x01};
+    UINT32 size = amp_sink->codec_size;
+    UINT8 *data = amp_sink->codec_data;
+    UINT8 *data_end = amp_sink->codec_data + amp_sink->codec_size;
+    UINT32 copied = 0;
+    int i, j, num_arrays, nal_len_size = 0;
+    UINT8 * priv = amp_sink->video_priv_data;
+
+    //Get code from ffmpeg hevc.c hevc_decode_extradata()
+    if(size > 3 && (data[0] || data[1] || data[2] > 1)){
+        /* It seems the extradata is encoded as hvcC format.
+         * Temporarily, we support configurationVersion==0 until 14496-15 3rd
+         * is finalized. When finalized, configurationVersion will be 1 and we
+         * can recognize hvcC by checking if avctx->extradata[0]==1 or not. */
+
+        if(data_end - data >= 23){
+            data += 21;
+            nal_len_size = (data[0]&0x3) + 1;
+            num_arrays = data[1];
+            data += 2;
+        }else{
+            return -1;
+        }
+
+        /* Decode nal units from hvcC. */
+        for (i = 0; i < num_arrays; i++) {
+            if ( (int)(data_end - data) < 3) {
+                return -1;
+            }
+
+            //int type = data[0] & 0x3f;
+            data++;
+            int cnt  = data[0]<<8 | data[1];
+            data += 2;
+
+            for (j = 0; j < cnt; j++) {
+                // +2 for the nal size field
+                int nalsize = (data[0]<<8 | data[1]);
+                data += 2;
+                if ( (int)(data_end - data) < nalsize) {
+                    return -1;
+                }
+
+                AmpMemcpy(priv + copied, nal_start_code, 4);
+                copied += 4;
+                AmpMemcpy(priv + copied, data, nalsize);
+                data += nalsize;
+                copied += nalsize;
+            }
+        }
+    }else{
+        GST_ERROR("No hvcC format found\n");
+    }
+
+    amp_sink->nal_len_size = nal_len_size;
+
+    return copied;
+}
+
+//return code.
+//>0, data being copied
+//<0, fail
+static int post_process_h265(Gstampvsink *amp_sink, uint8_t *data,
+        uint32_t size, uint8_t* dst, uint32_t dst_size)
+{
+    if(size < 4){
+        GST_ERROR("data too short\n");
+        return -1;
+    }
+
+    if (data[0] == 0x00 && data[1] == 0x00 && data[2] == 0x00 && data[3] == 0x01){
+        //NAL starting code can be detected
+        memcpy(dst, data, size);
+        return size;
+    }
+
+    //Need to add NAL starting code.
+    uint8_t nal_start_code[4] = {0x00, 0x00, 0x00, 0x01};
+    uint8_t *src = data;
+    uint32_t rp = 0, wp = 0;
+    uint32_t nal_len_size = amp_sink->nal_len_size;
+    uint32_t nal_len = 0;
+
+    while (rp < size) {
+        uint32_t n;
+        switch (nal_len_size) {
+            case 1:
+                nal_len = *src;
+                break;
+            case 2:
+                nal_len = src[rp] << 8 | src[rp + 1];
+                break;
+            case 3:
+                nal_len = src[rp] << 16 | src[rp + 1] << 8 |
+                    src[rp + 2];
+                break;
+            case 4:
+            default:
+                nal_len = src[rp] << 24 | src[rp + 1] << 16 |
+                    src[rp + 2] << 8 | src[rp + 3];
+                break;
+        }
+        if(wp + 4 < dst_size) {
+            memcpy(dst + wp, nal_start_code, 4);
+            rp += nal_len_size; wp += 4;
+        }else {
+            GST_ERROR("dst buffer too small\n");
+            return -1;
+        }
+
+        n = nal_len;
+        if(rp + n > size){
+            GST_ERROR("error, nal_len:%d > data left:%d\n", nal_len, size-rp);
+            n = size - rp;
+        }
+
+        if(wp + n > dst_size) {
+            GST_ERROR("dst buffer too small\n");
+            return -1;
+        }
+        memcpy(dst + wp, data + rp, n);
+        rp += n;
+        wp += n;
+    }
+
+    return wp;
+}
+
+static gboolean vdec_get_private(Gstampvsink * amp_sink)
+{
+    int priv_len = -1;
+
+    switch(amp_sink->video_codec){
+        case MEDIA_VES_AVC:
+            priv_len = pre_process_h264(amp_sink);
+            break;
+        case MEDIA_VES_HEVC:
+            priv_len = pre_process_h265(amp_sink);
+            break;
+        default:
+            return TRUE;
+    }
+
+    if(priv_len < 0) {
+        return FALSE;
+    }
+    amp_sink->video_priv_len = priv_len;
+    amp_sink->video_priv_done = FALSE;
+    return TRUE;
+}
+
+static HRESULT amp_allocate_buffer(Gstampvsink *amp_sink)
+{
+    HRESULT ret;
+    AMP_BD_HANDLE buf_desc;
+    int i = 0;
+    AMP_BDTAG_MEMINFO mem_info;
+    AMP_BDTAG_UNITSTART unit_start;
+
+    ret = AMP_BDCHAIN_Create(true, &amp_sink->video_stream_queue);
+    VERIFY_RESULT(ret);
+
+    ret = AMP_SHM_Allocate(AMP_SHM_DYNAMIC,
+            VIDEO_ES_BUFFER_SIZE,
+            1024,
+            &amp_sink->shm_v);
+    VERIFY_RESULT(ret);
+
+    ret = AMP_SHM_GetVirtualAddress(amp_sink->shm_v, 0,
+            (void **)&amp_sink->addr_v);
+    VERIFY_RESULT(ret);
+
+    amp_sink->wp_v = 0;
+    amp_sink->rp_v = 0;
+
+    mem_info.Header.eType = AMP_BDTAG_ASSOCIATE_MEM_INFO;
+    mem_info.Header.uLength = sizeof(AMP_BDTAG_MEMINFO);
+    mem_info.uMemHandle = amp_sink->shm_v;
+    mem_info.uMemOffset = 0;
+    mem_info.uSize = 0;
+
+    unit_start.Header.eType = AMP_BDTAG_BS_UNITSTART_CTRL;
+    unit_start.Header.uLength = sizeof(AMP_BDTAG_UNITSTART);
+
+
+    for (i = 0; i < MAX_VIDEO_STREAM_SIZE; i++) {
+        ret = AMP_BD_Allocate(&buf_desc);
+        VERIFY_RESULT(ret);
+
+        ret = AMP_BDTAG_Append(buf_desc, (UINT8 *)&mem_info, NULL, NULL);
+        VERIFY_RESULT(ret);
+
+        ret = AMP_BDTAG_Append(buf_desc, (UINT8 *)&unit_start, NULL, NULL);
+        VERIFY_RESULT(ret);
+
+        ret = AMP_BDCHAIN_PushItem(amp_sink->video_stream_queue,
+                buf_desc);
+        VERIFY_RESULT(ret);
+    }
+    return ret;
+}
+
+static void amp_free_buffer(Gstampvsink *amp_sink)
+{
+    HRESULT ret;
+    AMP_BD_HANDLE buf_desc;
+    UINT32 num_bd_allocated;
+    UINT32 i;
+    ret = AMP_BDCHAIN_GetItemNum(amp_sink->video_stream_queue,
+            &num_bd_allocated);
+    VERIFY_RESULT(ret);
+
+    for (i = 0; i < num_bd_allocated; i++) {
+        ret = AMP_BDCHAIN_PopItem(amp_sink->video_stream_queue,
+                &buf_desc);
+        if(ret == SUCCESS)
+            AMP_BD_Free(buf_desc);
+    }
+
+    if(amp_sink->video_stream_queue)
+        AMP_BDCHAIN_Destroy(amp_sink->video_stream_queue);
+
+    if(amp_sink->shm_v)
+        AMP_SHM_Release(amp_sink->shm_v);
+}
+
+static gboolean same_meta_data(UINT8* old_p, UINT32 old_s, UINT8* p, UINT32 s)
+{
+    if(old_s != s)
+        return FALSE;
+    if(old_p == NULL && p == NULL)
+        return TRUE;
+    if(old_p == NULL)
+        return FALSE;
+    return (memcmp(old_p, p, s) == 0);
+}
+
+static gboolean amp_handle_event_caps(Gstampvsink* amp_sink, GstCaps* caps)
+{
+    GstStructure *caps_structure = gst_caps_get_structure(caps, 0);
+    UINT32 codec_int = 0;
+    UINT8* codec_data = NULL;
+    UINT32 codec_size = 0;
+
+    const GValue *buffer_point = gst_structure_get_value(caps_structure,"codec_data");
+    if(buffer_point) {
+        GstBuffer *buffer = gst_value_get_buffer(buffer_point);
+
+        codec_size = gst_buffer_get_size(buffer);
+        codec_data = (UINT8*)g_malloc(codec_size);
+        if(!codec_data){
+            GST_ERROR("Memory allocation failed for codec data");
+            return false;
+        }
+        gst_buffer_extract(buffer, 0, codec_data, codec_size);
+    } else {
+        GST_WARNING("Codec data in not present in caps structure");
+    }
+
+    const gchar * stream_format = gst_structure_get_name(caps_structure);
+    if(g_strrstr(stream_format,"video/x-h264")){
+        GST_INFO("video codec is H.264 / AVC\n");
+        codec_int = MEDIA_VES_AVC;
+    }else if(g_strrstr(stream_format,"video/x-h265")){
+        GST_INFO("video codec is H.265 / HEVC\n");
+        codec_int = MEDIA_VES_HEVC;
+    }else if(g_strrstr(stream_format,"video/x-vp9")){
+        GST_INFO("video codec is VP9\n");
+        codec_int = MEDIA_VES_VP9;
+
+    }else if(g_strrstr(stream_format,"video/x-vp8")){
+        GST_INFO("video codec is VP8\n");
+        codec_int = MEDIA_VES_VP8;
+    }else{
+        GST_ERROR("Unsuported codec format %s\n", stream_format);
+        g_free(codec_data);
+        return false;
+    }
+
+    if (amp_sink->video_codec == codec_int &&
+        same_meta_data(amp_sink->codec_data, amp_sink->codec_size, codec_data, codec_size)) {
+        GST_WARNING("Video codec is unchanged\n");
+        if(codec_data)
+            g_free(codec_data);
+        return true;
+    }
+
+    if(amp_sink->codec_data != NULL) {
+        g_free(amp_sink->codec_data);
+        amp_sink->codec_data = NULL;
+        amp_sink->codec_size = 0;
+    }
+
+    if(codec_size) {
+        amp_sink->codec_size = codec_size;
+        amp_sink->codec_data = (UINT8*)g_malloc(codec_size);
+        memcpy(amp_sink->codec_data, codec_data, codec_size);
+        g_free(codec_data);
+    }
+
+    amp_sink->video_codec = codec_int;
+    if(!vdec_get_private(amp_sink)) {
+        GST_ERROR("pasre ES header error\n");
+        goto error;
+    }
+    if(!amp_sink->pipeline_created) {
+        if(amp_vdec_open(amp_sink) != SUCCESS){
+            GST_ERROR("amp_vdec_open failed");
+            goto error;
+        }
+
+        if(amp_connect(amp_sink) != SUCCESS){
+            GST_ERROR("amp_connect failed");
+            goto error;
+        }
+
+        amp_sink->pipeline_created = TRUE;
+        if(amp_sink_set_state(amp_sink, AMP_EXECUTING) != SUCCESS) {
+            GST_ERROR("set state failed");
+            goto error;
+        }
+    }
+    return true;
+error:
+    g_free(amp_sink->codec_data);
+    amp_sink->codec_data = NULL;
+    amp_sink->codec_size = 0;
+    return false;
+}
+
+static void amp_reset_meta(Gstampvsink * amp_sink)
+{
+    amp_sink->secure = FALSE;
+    amp_sink->shm_v = 0;
+    amp_sink->wp_v = 0;
+    amp_sink->rp_v = 0;
+    amp_sink->stream_pos = 0;
+    amp_sink->addr_v = NULL;
+    amp_sink->video_codec = 0;
+    amp_sink->video_priv_len = 0;
+    amp_sink->video_priv_done = false;
+    if(amp_sink->codec_data)
+        g_free(amp_sink->codec_data);
+    amp_sink->video_priv_len = 0;
+    amp_sink->codec_data = NULL;
+    amp_sink->codec_size = 0;
+    amp_sink->nal_len_size = 0;
+    amp_sink->video_stream_queue = NULL;
+    amp_sink->hVdec = NULL;
+    amp_sink->hVdecListener = NULL;
+    if(amp_sink->cap_accepted) {
+        gst_caps_unref(amp_sink->cap_accepted);
+        amp_sink->cap_accepted = NULL;
+    }
+}
+
+static gboolean gst_ampvsink_send_event (GstElement * element, GstEvent * event)
+{
+  HRESULT result = SUCCESS;
+  GstWesterosSink *sink = (GstWesterosSink *)element;
+  Gstampvsink *amp_sink = &sink->soc.amp_sink;
+  switch (GST_EVENT_TYPE (event)) {
+    case GST_EVENT_SEEK:
+    {
+      GstPad *demux_pad = gst_pad_get_peer (amp_sink->sinkpad);
+      if (demux_pad != NULL) {
+        gst_pad_send_event (demux_pad, event);
+        gst_object_unref(demux_pad);
+      }
+      break;
+    }
+    default:
+      gst_event_unref(event);
+      break;
+  }
+  return true;
+}
+
+static GstCaps *
+gst_amp_sink_sink_getcaps (GstWesterosSink* sink, GstCaps * filter)
+{
+    Gstampvsink *amp_sink = &(sink->soc.amp_sink);
+    GstCaps *templ_caps = gst_pad_get_pad_template_caps (amp_sink->sinkpad);
+    if(filter) {
+        GstCaps *caps = gst_caps_intersect (filter, templ_caps);
+        gst_caps_unref (templ_caps);
+        return caps;
+    } else {
+        return templ_caps;
+    }
+}
+
+static gboolean
+gst_westeros_sink_sink_query (GstPad * pad, GstObject * parent, GstQuery * query)
+{
+    gboolean ret = FALSE;
+    GstWesterosSink *sink = GST_WESTEROS_SINK(parent);
+
+    GST_DEBUG_OBJECT (sink, "received sink query %d, %s", GST_QUERY_TYPE (query),
+            GST_QUERY_TYPE_NAME (query));
+
+    switch (GST_QUERY_TYPE (query)) {
+        case GST_QUERY_CAPS:
+        {
+            GstCaps *filter, *caps;
+            gst_query_parse_caps (query, &filter);
+            GST_LOG_OBJECT (sink, "filter caps %" GST_PTR_FORMAT, filter);
+            caps = gst_amp_sink_sink_getcaps (sink, filter);
+            gst_query_set_caps_result (query, caps);
+            GST_LOG_OBJECT (sink, "return caps %" GST_PTR_FORMAT, caps);
+            gst_caps_unref (caps);
+            ret = TRUE;
+            break;
+        }
+        case GST_QUERY_ACCEPT_CAPS:
+        {
+            gst_westeros_sink_soc_query_accept_caps(sink, query);
+            ret = TRUE;
+            break;
+        }
+        default:
+            ret = gst_pad_query_default (pad, parent, query);
+    }
+    return ret;
+}
+
+/**
+ * Create the pads ,register and add the pad to the plugin
+ */
+static gboolean gst_createpads_amp_sink(GstWesterosSink *sink) {
+    Gstampvsink *amp_sink = &(sink->soc.amp_sink);
+    /* data pad */
+    amp_sink->sinkpad = gst_pad_new_from_static_template(&sink_amp_sink_pad, "sink");
+
+    gst_pad_set_event_function (amp_sink->sinkpad,
+            GST_DEBUG_FUNCPTR(gst_amp_sink_event));
+    gst_pad_set_chain_function (amp_sink->sinkpad,
+            GST_DEBUG_FUNCPTR(gst_amp_vdec_chain));
+    gst_pad_set_query_function (amp_sink->sinkpad,
+            GST_DEBUG_FUNCPTR (gst_westeros_sink_sink_query));
+    gst_element_add_pad(GST_ELEMENT(sink), amp_sink->sinkpad);
+
+    return TRUE;
+}
+
+/**
+ *  Function called when the declared arguments of the plugin are to be set.
+ */
+static void gst_ampvsink_set_property (GObject * object, guint prop_id,
+    const GValue * value, GParamSpec * pspec)
+{
+  GstWesterosSink *sink = GST_WESTEROS_SINK(object);
+  Gstampvsink *amp_sink = &sink->soc.amp_sink;
+  GstElement *element = GST_ELEMENT(sink);
+  AMP_STATE eState;
+  gchar **rectangle;
+  HRESULT result;
+  gint tvmode;
+  FILE *fDsPersistent = fopen("/opt/ds/hostData","r");
+  char dsbuffer[200];
+  switch (prop_id) {
+    case PROP_TV_MODE:
+    {
+        tvmode = g_value_get_enum (value);
+        if( 0 == tvmode)
+            amp_sink->tvmode = AMP_DISP_OUT_RES_FIRST;
+        else if(1 == tvmode)
+            amp_sink->tvmode = AMP_DISP_OUT_RES_480P60;
+        else if(2 == tvmode)
+            amp_sink->tvmode = AMP_DISP_OUT_RES_PAL_M;
+        else if(3 == tvmode)
+            amp_sink->tvmode = AMP_DISP_OUT_RES_PAL_BGH;
+        else if(4 == tvmode)
+            amp_sink->tvmode = AMP_DISP_OUT_RES_720P60;
+        else if(5 == tvmode)
+            amp_sink->tvmode = AMP_DISP_OUT_RES_720P50;
+        else if(6 == tvmode)
+            amp_sink->tvmode = AMP_DISP_OUT_RES_1080I60;
+        else if(7 == tvmode)
+            amp_sink->tvmode = AMP_DISP_OUT_RES_1080I50;
+        else if(8 == tvmode)
+            amp_sink->tvmode = AMP_DISP_OUT_RES_1080P60;
+        else if(9 == tvmode)
+            amp_sink->tvmode = AMP_DISP_OUT_RES_1080P50;
+
+        GST_INFO_OBJECT(sink, "tvmode is %d \n",amp_sink->tvmode);
+        AMP_RPC(result,
+                AMP_DISP_OUT_SetResolution,
+                amp_sink->Disp,
+                AMP_DISP_PLANE_MAIN,
+                amp_sink->tvmode,
+                AMP_DISP_OUT_BIT_DPE_8);
+        VERIFY_RESULT(result);
+
+        AMP_RPC(result,
+                AMP_DISP_OUT_HDMI_SetVidFmt,
+                amp_sink->Disp,
+                AMP_DISP_OUT_CLR_FMT_RGB888,
+                AMP_DISP_OUT_BIT_DPE_8,
+                1);
+        VERIFY_RESULT(result);
+        amp_sink->tvmode = tvmode;
+        break;
+    }
+    case PROP_PLANE:
+    {
+        amp_sink->plane = g_value_get_enum (value);
+        if(amp_sink->hVout) {
+            AMP_RPC(result, AMP_VOUT_GetState, amp_sink->hVout,&eState);
+            VERIFY_RESULT(result);
+            if(eState != AMP_EXECUTING) {
+                AMP_RPC(result, AMP_DISP_SetPlaneZOrder, amp_sink->Disp, amp_sink->plane, &(amp_sink->Zorder));
+            } else {
+                GST_DEBUG(" VOUT is in AMP_EXECUTING so can't set the property");
+            }
+        } else {
+            GST_DEBUG(" Parent Handle is Null ");
+        }
+        break;
+    }
+    case PROP_RECTANGLE:
+    {
+        rectangle = g_strsplit (g_value_get_string (value), ",", -1);
+
+        amp_sink->DstWin.iX=strtol (rectangle[0], NULL, 0);
+        amp_sink->DstWin.iY= strtol (rectangle[1], NULL, 0);
+
+        amp_sink->DstWin.iWidth= strtol (rectangle[2], NULL, 0);
+        amp_sink->DstWin.iHeight= strtol (rectangle[3], NULL, 0);
+
+        GST_DEBUG_OBJECT(sink, "The rectangle values are %d , %d ,%d, %d ",
+                amp_sink->DstWin.iX ,amp_sink->DstWin.iY,amp_sink->DstWin.iWidth,amp_sink->DstWin.iHeight);
+
+        //printf("AMPVOUT Resolution = %d\n", resolution);
+        if(fDsPersistent != NULL) {
+            fread(dsbuffer, sizeof(dsbuffer), 1, fDsPersistent);
+            if(strstr(dsbuffer, "720")){
+                amp_sink->resolution = 720;
+            }else if(strstr(dsbuffer, "1080")){
+                amp_sink->resolution = 1080;
+            }else if(strstr(dsbuffer, "2160")){
+                amp_sink->resolution = 2160;
+            }else{
+                g_print("[AMPVOUT] Resolution default case\n");
+                amp_sink->resolution = 720;
+            }
+            fclose(fDsPersistent);
+        } else {
+            amp_sink->resolution=720;
+            //  g_print("[AMPVOUT] Invalid ds persistent file discriptor \n");
+        }
+
+        if (1 == amp_sink->zoom) {
+            if( amp_sink->resolution == 2160 ) {
+                amp_sink->resolution = 2160;
+                amp_sink->SrcWin.iX=0;
+                amp_sink->SrcWin.iY=0;
+                amp_sink->SrcWin.iWidth=0;
+                amp_sink->SrcWin.iHeight=0;
+
+                amp_sink->DstWin.iX=0;
+                amp_sink->DstWin.iY=0;
+                amp_sink->DstWin.iWidth=3840;
+                amp_sink->DstWin.iHeight=2160;
+            } else if( amp_sink->resolution == 1080 ) {
+                amp_sink->resolution = 1080;
+                amp_sink->SrcWin.iX=0;
+                amp_sink->SrcWin.iY=0;
+                amp_sink->SrcWin.iWidth=0;
+                amp_sink->SrcWin.iHeight=0;
+
+                amp_sink->DstWin.iX=0;
+                amp_sink->DstWin.iY=0;
+                amp_sink->DstWin.iWidth=1920;
+                amp_sink->DstWin.iHeight=1080;
+            } else if( amp_sink->resolution == 720 ) {
+                amp_sink->resolution = 720;
+                amp_sink->SrcWin.iX=0;
+                amp_sink->SrcWin.iY=0;
+                amp_sink->SrcWin.iWidth=0;
+                amp_sink->SrcWin.iHeight=0;
+
+                amp_sink->DstWin.iX=0;
+                amp_sink->DstWin.iY=0;
+                amp_sink->DstWin.iWidth=1280;
+                amp_sink->DstWin.iHeight=720;
+            }
+        } else if(0 == amp_sink->zoom) {
+            amp_sink->SrcWin.iX=0;
+            amp_sink->SrcWin.iY=0;
+            amp_sink->SrcWin.iWidth=0;
+            amp_sink->SrcWin.iHeight=0;
+            /* modified for video scalling issue :
+               use rectangle passed from Mediaplayersink if window is lesser than 1080 */
+            if((amp_sink->DstWin.iWidth >= 1920) ||(amp_sink->DstWin.iHeight >=1080))
+            {
+                amp_sink->DstWin.iX=0;
+                amp_sink->DstWin.iY=0;
+                amp_sink->DstWin.iWidth=0;
+                amp_sink->DstWin.iHeight=0;
+
+            }
+        }
+
+        if(amp_sink->Disp) {
+            UINT32 resId = 0;
+            /* query if disp out is set to 4k, scale video rectangle for 4k */
+            AMP_RPC(result,
+                    AMP_DISP_OUT_GetResolution,
+                    amp_sink->Disp,
+                    AMP_DISP_PLANE_MAIN,
+                    &resId);
+            VERIFY_RESULT(result);
+            if((resId >= AMP_DISP_OUT_RES_4Kx2K_MIN) && (resId < AMP_DISP_OUT_RES_4Kx2K_MAX))
+            {
+                /* scale the video rectangle window for 4k*/
+                amp_sink->DstWin.iX *= 2;
+                amp_sink->DstWin.iY *= 2;
+                amp_sink->DstWin.iWidth *= 2;
+                amp_sink->DstWin.iHeight *= 2;
+            }
+            AMP_RPC(result, AMP_DISP_SetScale, amp_sink->Disp, amp_sink->plane, &amp_sink->SrcWin, &amp_sink->DstWin);
+            VERIFY_RESULT(result);
+        } else {
+            GST_DEBUG(" Parent Handle is Null ");
+        }
+        g_strfreev (rectangle);
+        break;
+    }
+    case PROP_FLUSH_REPEAT_FRAME:
+    {
+        amp_sink->repeatframe = g_value_get_boolean (value);
+        if(amp_sink->hVout) {
+            if(amp_sink->repeatframe) {
+                AMP_RPC(result,AMP_VOUT_SetLastFrameMode, amp_sink->hVout, AMP_VOUT_REPEATLASTFRAME);
+                VERIFY_RESULT(result);
+            } else {
+                AMP_RPC(result,AMP_VOUT_SetLastFrameMode, amp_sink->hVout, AMP_VOUT_SHOWBLACKSCREEN);
+                VERIFY_RESULT(result);
+            }
+        }
+        break;
+    }
+    case PROP_INTER_FRAME_DELAY:
+      amp_sink->framedelay = g_value_get_uint (value);
+      break;
+    case PROP_SLOW_MODE_RATE:
+      amp_sink->slowmoderate = g_value_get_int  (value);
+      break;
+    case PROP_STEP_FRAME:
+      amp_sink->steprate = g_value_get_uint  (value);
+      break;
+    case PROP_MUTE:
+    {
+        amp_sink->mute = g_value_get_uint (value);
+        if(amp_sink->Disp) {
+            AMP_RPC(result, AMP_DISP_SetPlaneMute, amp_sink->Disp, amp_sink->plane, amp_sink->mute);
+            VERIFY_RESULT(result);
+        }
+        break;
+    }
+    case PROP_ZOOM:
+      amp_sink->zoom = g_value_get_uint(value);
+      amp_sink->is_zoomSet=true;
+      break;
+    case PROP_PLAY_SPEED:
+    {
+        guint rate;
+        amp_sink->play_speed = g_value_get_float (value);
+        rate = 1000* amp_sink->play_speed;
+        GstClock* clk = gst_element_get_clock(element);
+        if(clk) {
+            g_object_set(G_OBJECT(clk), "clk-rate", rate, NULL);
+            gst_object_unref(clk);
+        }
+        break;
+    }
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+  }
+}
+
+
+/**
+ *   Function called when the declared arguments of the plugin is to be fetched.
+ */
+static void gst_ampvsink_get_property (GObject * object, guint prop_id,
+    GValue * value, GParamSpec * pspec)
+{
+  GstWesterosSink *sink = GST_WESTEROS_SINK(object);
+  Gstampvsink *amp_sink = &sink->soc.amp_sink;
+  HRESULT result;
+  GString *rectangle;
+  UINT32 left;
+  UINT32 right;
+  switch (prop_id) {
+    case PROP_TV_MODE:
+      g_value_set_enum (value, amp_sink->tvmode);
+      break;
+    case PROP_PLANE:
+      g_value_set_enum (value, amp_sink->plane);
+      break;
+    case PROP_RECTANGLE:
+      rectangle  = g_string_sized_new (32);
+      g_string_append_printf (rectangle, "%d", amp_sink->DstWin.iX);
+      g_string_append_printf (rectangle, ",%d", amp_sink->DstWin.iY);
+      g_string_append_printf (rectangle, ",%d", amp_sink->DstWin.iWidth);
+      g_string_append_printf (rectangle, ",%d", amp_sink->DstWin.iHeight);
+      g_value_take_string (value, g_string_free (rectangle, FALSE));
+
+      break;
+    case PROP_FLUSH_REPEAT_FRAME:
+      g_value_set_boolean (value, amp_sink->repeatframe);
+      break;
+    case PROP_INTER_FRAME_DELAY:
+      g_value_set_uint (value, amp_sink->framedelay);
+      break;
+    case PROP_SLOW_MODE_RATE:
+      g_value_set_int (value, amp_sink->slowmoderate);
+      break;
+    case PROP_CURRENT_PTS:
+      if(amp_sink->hVout){
+        AMP_RPC(result, AMP_VOUT_GetCurrentPTS, amp_sink->hVout,&left,&right);
+        amp_sink->currentpts = (long)(uint)right;
+      } else {
+        GST_DEBUG(" Parent Handle is Null ");
+      }
+      g_value_set_ulong (value, amp_sink->currentpts);
+      break;
+    case PROP_MUTE:
+      if(amp_sink->Disp){
+        AMP_RPC(result, AMP_DISP_GetPlaneMute, amp_sink->Disp, amp_sink->plane,&amp_sink->mute);
+      } else {
+        GST_DEBUG(" Parent Handle is Null ");
+      }
+      g_value_set_uint (value, amp_sink->mute);
+      break;
+    case PROP_CONTENT_FRAME_RATE:
+      g_value_set_uint (value, amp_sink->contentframerate);
+      break;
+    case PROP_ZOOM:
+       g_value_set_uint (value, amp_sink->zoom);
+       break;
+    case PROP_VOUT:
+       g_value_set_pointer (value, amp_sink->hVout);
+       break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+  }
+}
+
+static void waiting_for_BD_reset_buf(Gstampvsink* amp_sink)
+{
+    HRESULT ret;
+    UINT32 num_bd_remained;
+    UINT32 timeout = 100;
+    do {
+        ret = AMP_BDCHAIN_GetItemNum(amp_sink->video_stream_queue,
+                &num_bd_remained);
+        VERIFY_RESULT(ret);
+        if(num_bd_remained == MAX_VIDEO_STREAM_SIZE) {
+            break;
+        } else {
+            usleep(10000);
+            timeout--;
+            if(timeout == 0)
+                break;
+        }
+    }while(1);
+
+    if(timeout == 0)
+        GST_ERROR("BD recycling timeout");
+    else
+        GST_DEBUG("all Video BD returned\n");
+
+    amp_sink->wp_v = 0;
+    amp_sink->rp_v = 0;
+    amp_sink->stream_pos = 0;
+    amp_sink->video_priv_done = FALSE;
+}
+
+static void feed_thread_init(Gstampvsink *amp_sink)
+{
+    g_cond_init(&amp_sink->feed_cond);
+    g_mutex_init(&amp_sink->feed_mutex);
+    amp_sink->buf_q = g_queue_new();
+    amp_sink->stop = FALSE;
+    amp_sink->feed_t = g_thread_new("video feed thread", vsink_feed_task, amp_sink);
+}
+
+static void feed_thread_stop(Gstampvsink *amp_sink)
+{
+    g_mutex_lock(&amp_sink->feed_mutex);
+    amp_sink->stop = TRUE;
+    g_cond_signal(&amp_sink->feed_cond);
+    g_mutex_unlock(&amp_sink->feed_mutex);
+}
+
+static void feed_thread_push(Gstampvsink *amp_sink, GstBuffer* buf)
+{
+    g_mutex_lock(&amp_sink->feed_mutex);
+    g_queue_push_tail (amp_sink->buf_q, buf);
+    g_cond_signal(&amp_sink->feed_cond);
+    g_mutex_unlock(&amp_sink->feed_mutex);
+}
+
+
+static void buf_destroy(gpointer data)
+{
+    GstBuffer * buf = (GstBuffer *)data;
+    gst_buffer_unref(buf);
+}
+
+static void feed_thread_destroy(Gstampvsink *amp_sink)
+{
+    g_thread_join(amp_sink->feed_t);
+    g_cond_clear(&amp_sink->feed_cond);
+    g_mutex_clear(&amp_sink->feed_mutex);
+    g_queue_free_full (amp_sink->buf_q, buf_destroy);
+}
+
+
+/**
+ * To handle the change state of the plugin
+ */
+static GstStateChangeReturn gst_ampvsink_change_state (GstElement * element, GstStateChange transition)
+{
+  HRESULT result = SUCCESS;
+  AMP_STATE eState;
+  g_return_val_if_fail (GST_IS_WESTEROS_SINK (element), GST_STATE_CHANGE_FAILURE);
+
+  GstWesterosSink *sink = GST_WESTEROS_SINK(element);
+  Gstampvsink *amp_sink = &sink->soc.amp_sink;
+
+  switch (transition) {
+    case GST_STATE_CHANGE_NULL_TO_READY:
+    {
+      GstClock *clk;
+      VERIFY_RESULT(result);
+      AMP_RPC(result, AMP_FACTORY_CreateComponent,
+              hFactory, AMP_COMPONENT_VDEC, 0, &amp_sink->hVdec);
+      VERIFY_RESULT(result);
+      AMP_RPC(result, AMP_FACTORY_CreateComponent,
+              hFactory, AMP_COMPONENT_VOUT, 0, &amp_sink->hVout);
+      VERIFY_RESULT(result);
+
+      if(amp_disp_open(amp_sink) != SUCCESS)
+          return GST_STATE_CHANGE_FAILURE;
+
+      if(amp_vout_open(amp_sink) != SUCCESS)
+          return GST_STATE_CHANGE_FAILURE;
+
+      clk = gst_element_get_clock(element);
+      g_object_get(G_OBJECT(clk), "clk-handle", &amp_sink->hClk, NULL);
+      GST_DEBUG(" GST_STATE_CHANGE_NULL_TO_READY ");
+      gst_object_unref(clk);
+      break;
+    }
+    case GST_STATE_CHANGE_READY_TO_PAUSED:
+    {
+      feed_thread_init(amp_sink);
+      if(amp_allocate_buffer(amp_sink) != SUCCESS){
+          GST_ERROR("amp_allocate_buffer failed");
+          return GST_STATE_CHANGE_FAILURE;
+      }
+      GST_DEBUG(" GST_STATE_CHANGE_READY_TO_PAUSED ");
+      break;
+    }
+    case GST_STATE_CHANGE_PAUSED_TO_PLAYING:
+    {
+      if(amp_sink->m_isPaused)
+      {
+        amp_sink->m_isPaused = false;
+        if(amp_sink->cap_accepted)
+          amp_sink_set_state(amp_sink, AMP_EXECUTING);
+      }
+      VERIFY_RESULT(result);
+      GST_DEBUG(" GST_STATE_CHANGE_PAUSED_TO_PLAYING ");
+      break;
+    }
+    default:
+      break;
+  }
+
+  switch (transition) {
+    case GST_STATE_CHANGE_PLAYING_TO_PAUSED:
+    {
+      GST_DEBUG(" GST_STATE_CHANGE_PLAYING_TO_PAUSED ");
+      break;
+    }
+    case GST_STATE_CHANGE_PAUSED_TO_READY:
+    {
+      feed_thread_stop(amp_sink);
+      result = amp_sink_set_state(amp_sink, AMP_IDLE);
+      if(amp_sink->pipeline_created) {
+          waiting_for_BD_reset_buf(amp_sink);
+          amp_disconnect(amp_sink);
+          amp_vdec_close(amp_sink);
+          amp_sink->pipeline_created = FALSE;
+          amp_sink->video_codec = 0;
+      }
+      amp_free_buffer(amp_sink);
+      feed_thread_destroy(amp_sink);
+      GST_DEBUG(" GST_STATE_CHANGE_PAUSED_TO_READY ");
+      break;
+    }
+    case GST_STATE_CHANGE_READY_TO_NULL:
+    {
+      amp_vout_close(amp_sink);
+      amp_sink_destroy(amp_sink);
+      amp_reset_meta(amp_sink);
+
+      GST_DEBUG(" GST_STATE_CHANGE_READY_TO_NULL ");
+      break;
+    }
+    default:
+      break;
+  }
+
+  return GST_STATE_CHANGE_SUCCESS;
+}
+
+void append_unit_start(AMP_BDTAG_UNITSTART* p, GstClockTime pts, UINT32 pos)
+{
+    if(p) {
+        p->uPtsHigh = (UINT32)(pts >> 32);
+        p->uPtsLow = (UINT32)(pts & 0x0FFFFFFFF);
+        p->uStrmPos = pos;
+    }
+}
+
+static FEED_RET feed_protection_data(Gstampvsink *amp_sink, GstBuffer *buf, GstProtectionMeta* meta,
+        GstClockTime pts, gboolean eos, UINT8 *private_data, UINT32 private_len) {
+    HRESULT ret = -1;
+    AMP_BD_HANDLE bd;
+    guint hShm;
+    gint offset, size;
+    UINT32 num_bd_remained;
+    AMP_SHM_HANDLE headerShm;
+    AMP_BDTAG_MEMINFO* mem_info;
+    AMP_BDTAG_UNITSTART* unit_start;
+
+    if(!gst_structure_get_uint(meta->info, "handle", &hShm) ||
+            !gst_structure_get_int(meta->info, "offset", &offset) ||
+            !gst_structure_get_int(meta->info, "size", &size)) {
+        GST_ERROR("corrupted meta\n");
+        return FEED_ERR;
+    }
+
+    int bd_needed = private_len>0?2:1;
+    ret = AMP_BDCHAIN_GetItemNum(amp_sink->video_stream_queue,&num_bd_remained);
+    VERIFY_RESULT(ret);
+    if(num_bd_remained < bd_needed) {
+        return FEED_RETRY;
+    }
+
+    if(private_len > 0 && !eos){
+        void *p;
+        /*This SHM will be released in amp_sink_callback */
+        ret = AMP_SHM_Allocate(AMP_SHM_DYNAMIC, private_len, 32, &headerShm);
+        VERIFY_RESULT(ret);
+        AMP_SHM_GetVirtualAddress(headerShm, 0, &p);
+        memcpy(p, private_data, private_len);
+
+        ret = AMP_BDCHAIN_PopItem(amp_sink->video_stream_queue, &bd);
+        VERIFY_RESULT(ret);
+
+        ret = AMP_BDTAG_GetWithType(bd, AMP_BDTAG_ASSOCIATE_MEM_INFO, NULL, (void**)&mem_info);
+        VERIFY_RESULT(ret);
+        mem_info->Header.eType = AMP_BDTAG_ASSOCIATE_MEM_INFO;
+        mem_info->Header.uLength = sizeof(AMP_BDTAG_MEMINFO);
+        mem_info->uMemHandle = headerShm;
+        mem_info->uMemOffset = 0;
+        mem_info->uSize = private_len;
+
+        amp_sink->stream_pos += private_len;
+
+        ret = AMP_SHM_CleanCache(headerShm, 0, private_len);
+        VERIFY_RESULT(ret);
+        AMP_RPC(ret, AMP_VDEC_PushBD, amp_sink->hVdec, AMP_PORT_INPUT, 0, bd);
+        VERIFY_RESULT(ret);
+        amp_sink->video_priv_done = true;
+    }
+
+    ret = AMP_BDCHAIN_PopItem(amp_sink->video_stream_queue, &bd);
+    VERIFY_RESULT(ret);
+
+    ret = AMP_BDTAG_GetWithType(bd, AMP_BDTAG_ASSOCIATE_MEM_INFO, NULL, (void**)&mem_info);
+    VERIFY_RESULT(ret);
+    /* mem info tag*/
+    mem_info->Header.eType = AMP_BDTAG_ASSOCIATE_MEM_INFO;
+    mem_info->Header.uLength = sizeof(AMP_BDTAG_MEMINFO);
+    mem_info->uMemHandle = hShm;
+    mem_info->uMemOffset = offset;
+    mem_info->uSize = size;
+
+    if (!(eos /*&& !amp_sink->codec_size*/)) {
+        mem_info->uFlag &= ~AMP_MEMINFO_FLAG_EOS_MASK;
+    } else {
+        mem_info->uFlag |= AMP_MEMINFO_FLAG_EOS_MASK;
+        GST_INFO("send video eos\n");
+    }
+
+    /* pts tag */
+    ret = AMP_BDTAG_GetWithType(bd, AMP_BDTAG_BS_UNITSTART_CTRL, NULL, (void**)&unit_start);
+    VERIFY_RESULT(ret);
+    append_unit_start(unit_start, pts , amp_sink->stream_pos);
+
+    amp_sink->stream_pos += size;
+
+    AMP_RPC(ret, AMP_VDEC_PushBD, amp_sink->hVdec, AMP_PORT_INPUT, 0, bd);
+    VERIFY_RESULT(ret);
+    return FEED_DONE;
+}
+
+static LINEAR_POS enough_video_linear_space(Gstampvsink *amp_sink, UINT32 length)
+{
+	UINT32 left_end, left_beg;
+	if(amp_sink->wp_v > VIDEO_ES_BUFFER_SIZE) {
+		GST_ERROR("should not happen\n");
+		return NO_LINEAR;
+	}
+	if (amp_sink->rp_v > amp_sink->wp_v) {
+		left_end = amp_sink->rp_v - amp_sink->wp_v;
+		left_beg = 0;
+	} else {
+		left_end = (VIDEO_ES_BUFFER_SIZE - amp_sink->wp_v);
+		left_beg = amp_sink->rp_v;
+	}
+	if(left_end >= length)
+		return LINEAR_END;
+	else if(left_beg >= length)
+		return LINEAR_BEG;
+	else
+		return NO_LINEAR;
+}
+
+static FEED_RET amp_feed_amp_sink(Gstampvsink* amp_sink, GstBuffer *buf)
+{
+    FEED_RET retval;
+    AMP_COMPONENT handle = amp_sink->hVdec;
+    HRESULT ret = -1;
+    UINT32 num_bd_remained = 0;
+    AMP_BD_HANDLE buf_desc;
+    AMP_BDTAG_MEMINFO* mem_info;
+    AMP_BDTAG_UNITSTART* unit_start;
+    UINT8 *buf_mapped = NULL;
+    GstMapInfo info;
+    gsize orig_length = gst_buffer_get_size(buf);
+    UINT32 length = 0;
+    GstClockTime pts = GST_BUFFER_PTS(buf);
+    //GstClockTime duration = GST_BUFFER_DURATION(buf);
+    guint64 eos = GST_BUFFER_OFFSET_END(buf);
+    UINT8 *private_data = NULL;
+    UINT32 private_len = 0;
+    AVRational new_base;
+    AVRational time_base;
+    LINEAR_POS buf_pos;
+    UINT32 buf_max;
+    /* rescaling the PTS value with time_base of nano-second to the
+       default value of MPEG-TS time_base(i.e.,new_base) for AVSync */
+    new_base.num = 1;
+    new_base.den = 90000;
+    time_base.num=1;
+    time_base.den=1000000000;
+    if (pts != GST_CLOCK_TIME_NONE && pts >= 0) {
+        pts = av_rescale_q(pts,time_base,new_base);
+    }
+    if (pts == GST_CLOCK_TIME_NONE || pts < 0) {
+        pts &= ~(AMP_PTS_VALID_MASK);
+    } else {
+        pts |= AMP_PTS_VALID_MASK;
+    }
+
+    if(amp_sink->video_codec == MEDIA_VES_HEVC ||
+            amp_sink->video_codec == MEDIA_VES_AVC) {
+        if(!amp_sink->video_priv_done){
+            //Always start from I-frame
+            if(GST_BUFFER_FLAG_IS_SET(buf, GST_BUFFER_FLAG_DELTA_UNIT)) {
+                GST_DEBUG("drop non-I frame\n");
+                return FEED_DONE;
+            }
+            private_len = amp_sink->video_priv_len;
+            private_data = amp_sink->video_priv_data;
+            if(private_len == 0) {
+                GST_WARNING("no ES header in container\n");
+                amp_sink->video_priv_done = TRUE;
+            }
+        }
+    } else {
+        private_len = amp_sink->video_priv_len;
+        private_data = amp_sink->video_priv_data;
+    }
+
+    GstProtectionMeta* meta = gst_buffer_get_protection_meta(buf);
+    if(meta != NULL){
+        amp_sink->secure = TRUE;
+        if(amp_sink->shm_v) {
+            AMP_SHM_Release(amp_sink->shm_v);
+            amp_sink->shm_v = 0;
+            amp_sink->addr_v = NULL;
+        }
+        //non-CC buffer frame-in feeding
+        return feed_protection_data(amp_sink, buf, meta, pts, eos!=0, private_data, private_len);
+    }
+
+    ret = AMP_BDCHAIN_GetItemNum(amp_sink->video_stream_queue,&num_bd_remained);
+    VERIFY_RESULT(ret);
+    if(num_bd_remained == 0) {
+        return FEED_RETRY;
+    }
+
+    //Add 0.5M for NAL padding
+    UINT32 needed = orig_length + private_len + 512*1024;
+    buf_pos = enough_video_linear_space(amp_sink, needed);
+    if(buf_pos == NO_LINEAR) {
+        return FEED_RETRY;
+    }
+
+    if(buf_pos == LINEAR_END) {
+        buf_mapped = amp_sink->addr_v + amp_sink->wp_v;
+        buf_max = VIDEO_ES_BUFFER_SIZE - amp_sink->wp_v;
+    } else {
+        buf_mapped = amp_sink->addr_v;
+        buf_max = amp_sink->rp_v;
+    }
+
+    if (private_len && !eos) {
+        AmpMemcpy(buf_mapped, private_data, private_len);
+        amp_sink->video_priv_done = TRUE;
+        buf_mapped += private_len;
+        length += private_len;
+    }
+
+    if(orig_length) {
+        gst_buffer_map(buf, &info, GST_MAP_READ);
+        if (info.data && info.size > 0) {
+            int32_t copied = 0;
+
+            switch(amp_sink->video_codec) {
+                case MEDIA_VES_AVC:
+                    copied = post_process_h264(amp_sink, info.data, info.size, buf_mapped, buf_max);
+                    break;
+                case MEDIA_VES_HEVC:
+                    copied = post_process_h265(amp_sink, info.data, info.size, buf_mapped, buf_max);
+                    break;
+                default:
+                    memcpy(buf_mapped, info.data, info.size);
+                    copied = info.size;
+                    break;
+            }
+            if(copied < 0){
+                GST_ERROR("post_process  fail\n");
+                goto ERROR;
+            }
+            length += copied;
+        }
+    }
+
+    ret = AMP_BDCHAIN_PopItem(amp_sink->video_stream_queue, &buf_desc);
+    VERIFY_RESULT(ret);
+
+    /* mem info tag*/
+    ret = AMP_BDTAG_GetWithType(buf_desc, AMP_BDTAG_ASSOCIATE_MEM_INFO, NULL, (void**)&mem_info);
+    VERIFY_RESULT(ret);
+    mem_info->Header.eType = AMP_BDTAG_ASSOCIATE_MEM_INFO;
+    mem_info->Header.uLength = sizeof(AMP_BDTAG_MEMINFO);
+    mem_info->uMemHandle = amp_sink->shm_v;
+
+    if(buf_pos == LINEAR_END)
+        mem_info->uMemOffset = amp_sink->wp_v;
+    else
+        mem_info->uMemOffset = 0;
+    mem_info->uSize = length;
+    mem_info->uFlag = AMP_MEMINFO_FLAG_DATA_IN_CACHE_MASK;
+    if (!eos) {
+        mem_info->uFlag &= ~AMP_MEMINFO_FLAG_EOS_MASK;
+    } else {
+        mem_info->uFlag |= AMP_MEMINFO_FLAG_EOS_MASK;
+        GST_INFO("send video eos\n");
+    }
+
+    /* pts tag */
+    ret = AMP_BDTAG_GetWithType(buf_desc,AMP_BDTAG_BS_UNITSTART_CTRL, NULL, (void**)&unit_start);
+    VERIFY_RESULT(ret);
+    append_unit_start(unit_start, pts , amp_sink->stream_pos);
+
+    if(length != 0) {
+        if(buf_pos == LINEAR_END)
+            amp_sink->wp_v += length;
+        else
+            amp_sink->wp_v = length;
+
+        amp_sink->stream_pos += length;
+    }
+
+    AMP_RPC(ret,
+            AMP_VDEC_PushBD,
+            handle,
+            AMP_PORT_INPUT,
+            0,
+            buf_desc);
+    VERIFY_RESULT(ret);
+    GST_LOG("VDEC push BD:%d pts:%x spos: %x wo:%x buf_pos:%d len:%x\n",
+            AMP_BD_GET_BDID(buf_desc), unit_start->uPtsLow,
+            amp_sink->stream_pos, amp_sink->wp_v,
+            buf_pos, length);
+    retval = FEED_DONE;
+
+ERROR:
+    if(orig_length)
+        gst_buffer_unmap(buf,&info);
+    return retval;
+}
+
+static GstFlowReturn
+gst_amp_vdec_chain (GstPad * pad, GstObject * parent, GstBuffer * buf)
+{
+    AMP_STATE state;
+    HRESULT ret;
+
+    GstWesterosSink* sink = GST_WESTEROS_SINK(parent);
+    Gstampvsink *amp_sink = &sink->soc.amp_sink;
+
+    GST_BUFFER_OFFSET_END(buf) = 0;
+    GST_BUFFER_OFFSET(buf) = 0;
+
+    AMP_RPC(ret, AMP_COMPONENT_GetState, amp_sink->hVdec, &state);
+    VERIFY_RESULT(ret);
+    if(state != AMP_EXECUTING && state != AMP_PAUSED) {
+        GST_DEBUG("VDEC drop buf in state: %d\n",state);
+        gst_buffer_unref(buf);
+        return GST_FLOW_OK;
+    }
+
+    feed_thread_push(amp_sink, buf);
+
+    return GST_FLOW_OK;
+}
+
+typedef struct {
+    UINT32 signature;
+    UINT16 version;
+    UINT16 hdr_len;
+    UINT32 fcc;
+    UINT16 width;
+    UINT16 height;
+    UINT32 frame_rate;
+    UINT32 time_scale;
+    UINT32 num_frames;
+    UINT32 reserved;
+    UINT32 frame_size;
+    signed long long int  pts;
+}__attribute__ ((packed)) VP9_IVF;
+
+typedef struct {
+    UINT32 frame_size;
+    signed long long int  pts;
+}__attribute__ ((packed)) VP9_FHDR;
+
+static int process_vp9(Gstampvsink* amp_sink, GstBuffer *buf) {
+    gsize length = gst_buffer_get_size(buf);
+    GstClockTime pts = GST_BUFFER_PTS(buf);
+
+    if(amp_sink->stream_pos == 0) {
+        VP9_IVF *IVFheader;
+        IVFheader = (VP9_IVF *)amp_sink->video_priv_data;
+        amp_sink->video_priv_len = sizeof(VP9_IVF);
+
+        IVFheader->signature  = 0x46494b44;
+        IVFheader->version = 0x0;
+        IVFheader->hdr_len  = 0x20;
+        IVFheader->fcc   = 0x30395056;
+        IVFheader->width      = 1920;
+        IVFheader->height = 1080;
+        IVFheader->frame_rate = 0;
+        IVFheader->time_scale = 0;
+
+        IVFheader->num_frames = 1000;
+        IVFheader->reserved = 0x0;
+        IVFheader->frame_size = length;
+        IVFheader->pts = pts;
+    } else {
+        VP9_FHDR *VP9header = (VP9_FHDR *)amp_sink->video_priv_data;
+        amp_sink->video_priv_len = sizeof(VP9_FHDR);
+        VP9header->frame_size = length;
+        VP9header->pts = pts;
+    }
+}
+
+static int process_vp8(Gstampvsink* amp_sink, GstBuffer *buf) {
+    gsize length = gst_buffer_get_size(buf);
+    GstClockTime pts = GST_BUFFER_PTS(buf);
+
+    if(amp_sink->stream_pos == 0) {
+        VP9_IVF *IVFheader;
+        IVFheader = (VP9_IVF *)amp_sink->video_priv_data;
+        amp_sink->video_priv_len = sizeof(VP9_IVF);
+
+        IVFheader->signature  = 0x46494b44;
+        IVFheader->version = 0x0;
+        IVFheader->hdr_len  = 0x20;
+        IVFheader->fcc   = 0x30385056;
+        IVFheader->width      = 1920;
+        IVFheader->height = 1080;
+        IVFheader->frame_rate = 0;
+        IVFheader->time_scale = 0;
+
+        IVFheader->num_frames = 1000;
+        IVFheader->reserved = 0x0;
+        IVFheader->frame_size = length;
+        IVFheader->pts = pts;
+    } else {
+        VP9_FHDR *VP9header = (VP9_FHDR *)amp_sink->video_priv_data;
+        amp_sink->video_priv_len = sizeof(VP9_FHDR);
+        VP9header->frame_size = length;
+        VP9header->pts = pts;
+    }
+}
+
+
+static gpointer vsink_feed_task(gpointer data)
+{
+   Gstampvsink *amp_sink = (Gstampvsink *)data;
+    while(1){
+        guint num;
+        g_mutex_lock(&amp_sink->feed_mutex);
+        while(g_queue_get_length (amp_sink->buf_q) == 0 &&
+                !amp_sink->stop){
+            g_cond_wait(&amp_sink->feed_cond, &amp_sink->feed_mutex);
+        }
+        g_mutex_unlock(&amp_sink->feed_mutex);
+
+        if(amp_sink->stop)
+            return NULL;
+
+        FEED_RET ret;
+        g_mutex_lock(&amp_sink->feed_mutex);
+        num = g_queue_get_length (amp_sink->buf_q);
+        for(guint i=0; i< num; i++){
+            GstBuffer *buf = (GstBuffer*)g_queue_peek_head(amp_sink->buf_q);
+
+            if(amp_sink->video_codec == MEDIA_VES_VP9) {
+                process_vp9(amp_sink, buf);
+            }else if(amp_sink->video_codec == MEDIA_VES_VP8) {
+                process_vp8(amp_sink, buf);
+            }
+
+            ret = amp_feed_amp_sink(amp_sink, buf);
+            if(ret == FEED_RETRY){
+                usleep(10000);
+                break;
+            }else if(ret == FEED_DONE){
+                gst_buffer_unref(buf);
+                g_queue_pop_head (amp_sink->buf_q);
+            }else if( ret == FEED_ERR){
+                gst_buffer_unref(buf);
+                GST_ERROR("feed error");
+                break;
+            }
+        }
+        g_mutex_unlock(&amp_sink->feed_mutex);
+
+        if(ret == FEED_ERR)
+            break;
+    }
+    return NULL;
+}
+/**
+ * Used to initialize the class only once ,specifying what signals
+ * arguments and virtual functions the class has.
+ * */
+static void gst_ampvsink_class_init (GstWesterosSinkClass *klass)
+{
+    GObjectClass *gobject_class = (GObjectClass *) klass;
+    GstElementClass *gstelement_class = (GstElementClass *) klass;
+
+    gstelement_class->query = GST_DEBUG_FUNCPTR(gst_ampvsink_sink_query_function);
+    gstelement_class->send_event = GST_DEBUG_FUNCPTR (gst_ampvsink_send_event);
+
+#if 0
+    gst_element_class_set_metadata (gstelement_class,
+            "AmpVout",
+            "Video Render",
+            "AMP GST plugin for WPEWebkit",
+            "http://www.synaptics.com/");
+#endif
+    gst_element_class_add_pad_template (gstelement_class,
+            gst_static_pad_template_get (&sink_amp_sink_pad));
+
+    g_object_class_install_property (gobject_class, PROP_TV_MODE,
+            g_param_spec_enum("tv-mode","tv-mode",
+                " Define the television mode",
+                GST_AMP_TV_MODE, 0,
+                (GParamFlags)(G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS)));
+
+    g_object_class_install_property (gobject_class, PROP_PLANE,
+            g_param_spec_enum ("gdl-plane","gdl-plane",
+                "define the Universal Pixel Plane used in the GDL layer",
+                GST_AMP_PLANE, 0,
+                (GParamFlags)(G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS)));
+
+    g_object_class_install_property (gobject_class, PROP_RECTANGLE,
+            g_param_spec_string ("rectangle", "rectangle",
+                "The destination rectangle, (0,0,0,0) full screen"
+                " eg 0,0,0,0 ", DEFAULT_PROP_RECTANGLE,
+                (GParamFlags)(G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS)));
+
+    g_object_class_install_property (gobject_class, PROP_FLUSH_REPEAT_FRAME,
+            g_param_spec_boolean ("flush-repeate-frame", "flush-repate-frame",
+                " Keep displaying the last frame rather than a black one whilst flushing",DEFAULT_PROP_FLUSH_REPEAT_FRAME,
+                (GParamFlags)(G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS)));
+
+    g_object_class_install_property (gobject_class,  PROP_CURRENT_PTS,
+            g_param_spec_ulong ("currentpts", "currentPTS" ,"Value in seconds  (0 - 4294967295)",0 , 0,
+                DEFAULT_PROP_CURRENT_PTS, (GParamFlags)(G_PARAM_READABLE | G_PARAM_STATIC_STRINGS )));
+
+    g_object_class_install_property (gobject_class, PROP_INTER_FRAME_DELAY,
+            g_param_spec_uint ("inter-frame-delay","inter-frame-delay", "Enables fixed frame rate mode  (0 - 4294967295)",0 , 0,
+                DEFAULT_PROP_INTER_FRAME_DELAY, (GParamFlags)(G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS)));
+
+    g_object_class_install_property (gobject_class, PROP_SLOW_MODE_RATE,
+            g_param_spec_int ("slow-mode-rate", "slow-mode-rate",
+                "slow mode rate for video sink (-2000 to 2000)", 0 , G_MAXINT,
+                DEFAULT_PROP_SLOW_MODE_RATE,
+                (GParamFlags)(G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS)));
+
+    g_object_class_install_property (gobject_class, PROP_CONTENT_FRAME_RATE,
+            g_param_spec_uint ("contentframerate", " get content frame rate","contentframerate",
+                0 ,4505, DEFAULT_PROP_COUNTER_FRAME_RATE,
+                (GParamFlags)(G_PARAM_READABLE | G_PARAM_STATIC_STRINGS)));
+
+    g_object_class_install_property (gobject_class, PROP_STEP_FRAME,
+            g_param_spec_uint ("step-frame", "step-frame", "step-frame" ,
+                0 ,4505, DEFAULT_PROP_STEP_FRAME,
+                (GParamFlags)(G_PARAM_WRITABLE | G_PARAM_STATIC_STRINGS)));
+
+    g_object_class_install_property (gobject_class, PROP_MUTE,
+            g_param_spec_uint ("mute", "mute","mute",0 , 1, DEFAULT_PROP_MUTE,
+                (GParamFlags)(G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS )));
+
+    g_object_class_install_property (gobject_class, PROP_ZOOM,
+            g_param_spec_uint ("zoom","zoom","zoom",0 , 1, DEFAULT_PROP_ZOOM,
+                (GParamFlags)(G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS )));
+
+    g_object_class_install_property (gobject_class, PROP_PLAY_SPEED,
+            g_param_spec_float("play-speed", "play speed",
+                "Play Speed to be set or current play speed",
+                -G_MAXFLOAT, G_MAXFLOAT, DEFAULT_PLAY_SPEED,
+                G_PARAM_READWRITE));
+
+    g_object_class_install_property (gobject_class, PROP_VOUT,
+            g_param_spec_pointer ("vout", "vout amp handle",
+                "amp handle of vout instance",
+                (GParamFlags)(G_PARAM_READABLE | G_PARAM_STATIC_STRINGS)));
+
+}
+
+/**
+ * initialize the new element
+ * instantiate pads and add them to element
+ */
+static void gst_ampvsink_init (GstWesterosSink * sink) {
+    Gstampvsink * amp_sink = &(sink->soc.amp_sink);
+
+    memset(amp_sink, 0, sizeof(Gstampvsink));
+
+    amp_sink->westeros_sink = sink;
+    GST_OBJECT_FLAG_SET (GST_OBJECT (sink), GST_ELEMENT_FLAG_SINK | GST_ELEMENT_FLAG_REQUIRE_CLOCK);
+    gst_createpads_amp_sink(sink);
+}
+
+/*######################################################################*/
+
+static void sbFormat(void *data, struct wl_sb *wl_sb, uint32_t format)
+{
+   WESTEROS_UNUSED(wl_sb);
+   GstWesterosSink *sink= (GstWesterosSink*)data;
+   WESTEROS_UNUSED(sink);
+   printf("westeros-sink-soc: registry: sbFormat: %X\n", format);
+}
+
+static const struct wl_sb_listener sbListener = {
+	sbFormat
+};
+
+void gst_westeros_sink_soc_class_init(GstWesterosSinkClass *klass)
+{
+    gst_ampvsink_class_init(klass);
+}
+
+gboolean gst_westeros_sink_soc_init( GstWesterosSink *sink )
+{
+    gst_ampvsink_init(sink);
+    return true;
+}
+
+void gst_westeros_sink_soc_term( GstWesterosSink *sink )
+{
+    if ( sink->soc.sb ) {
+        wl_sb_destroy( sink->soc.sb );
+        sink->soc.sb= 0;
+    }
+
+    GST_DEBUG("gst_westeros_sink_soc_term");
+}
+
+void gst_westeros_sink_soc_set_property(GObject *object, guint prop_id, const GValue *value, GParamSpec *pspec)
+{
+    gst_ampvsink_set_property(object, prop_id, value, pspec);
+}
+
+void gst_westeros_sink_soc_get_property(GObject *object, guint prop_id, GValue *value, GParamSpec *pspec)
+{
+    gst_ampvsink_get_property(object, prop_id, value, pspec);
+}
+
+void gst_westeros_sink_soc_registryHandleGlobal( GstWesterosSink *sink,
+                                 struct wl_registry *registry, uint32_t id,
+		                           const char *interface, uint32_t version)
+{
+    WESTEROS_UNUSED(version);
+    int len;
+
+    len= strlen(interface);
+
+    if ((len==5) && (strncmp(interface, "wl_sb", len) == 0))
+    {
+        sink->soc.sb= (struct wl_sb*)wl_registry_bind(registry, id, &wl_sb_interface, 1);
+        printf("westeros-sink-soc: registry: sb %p\n", (void*)sink->soc.sb);
+        wl_proxy_set_queue((struct wl_proxy*)sink->soc.sb, sink->queue);
+        wl_sb_add_listener(sink->soc.sb, &sbListener, sink);
+        printf("westeros-sink-soc: registry: done add sb listener\n");
+    }
+}
+
+void gst_westeros_sink_soc_registryHandleGlobalRemove( GstWesterosSink *sink,
+        struct wl_registry *registry,
+        uint32_t name)
+{
+    WESTEROS_UNUSED(sink);
+    WESTEROS_UNUSED(registry);
+    WESTEROS_UNUSED(name);
+}
+
+gboolean gst_westeros_sink_soc_null_to_ready( GstWesterosSink *sink, gboolean *passToDefault )
+{
+    GstElement *element = GST_ELEMENT(sink);
+    gst_ampvsink_change_state(element, GST_STATE_CHANGE_NULL_TO_READY);
+    return TRUE;
+}
+
+gboolean gst_westeros_sink_soc_ready_to_paused( GstWesterosSink *sink, gboolean *passToDefault )
+{
+    GstElement *element = GST_ELEMENT(sink);
+    gst_ampvsink_change_state(element, GST_STATE_CHANGE_READY_TO_PAUSED);
+    return TRUE;
+}
+
+gboolean gst_westeros_sink_soc_paused_to_playing( GstWesterosSink *sink, gboolean *passToDefault )
+{
+    GstElement *element = GST_ELEMENT(sink);
+    gst_ampvsink_change_state(element, GST_STATE_CHANGE_PAUSED_TO_PLAYING);
+    return TRUE;
+}
+
+gboolean gst_westeros_sink_soc_playing_to_paused( GstWesterosSink *sink, gboolean *passToDefault )
+{
+    LOCK( sink );
+    sink->videoStarted= FALSE;
+    UNLOCK( sink );
+
+    GstElement *element = GST_ELEMENT(sink);
+    gst_ampvsink_change_state(element, GST_STATE_CHANGE_PLAYING_TO_PAUSED);
+
+    *passToDefault= false;
+
+    return TRUE;
+}
+
+gboolean gst_westeros_sink_soc_paused_to_ready( GstWesterosSink *sink, gboolean *passToDefault )
+{
+    LOCK( sink );
+    sink->videoStarted= FALSE;
+    UNLOCK( sink );
+
+    GstElement *element = GST_ELEMENT(sink);
+    gst_ampvsink_change_state(element, GST_STATE_CHANGE_PAUSED_TO_READY);
+
+    *passToDefault= false;
+
+    return TRUE;
+}
+
+gboolean gst_westeros_sink_soc_ready_to_null( GstWesterosSink *sink, gboolean *passToDefault )
+{
+    WESTEROS_UNUSED(sink);
+
+    GstElement *element = GST_ELEMENT(sink);
+    gst_ampvsink_change_state(element, GST_STATE_CHANGE_READY_TO_NULL);
+
+    *passToDefault= false;
+
+    return TRUE;
+}
+
+void gst_westeros_sink_soc_query_accept_caps(GstWesterosSink *sink, GstQuery *query)
+{
+    GstCaps *caps;
+    Gstampvsink * amp_sink = &(sink->soc.amp_sink);
+    gboolean accepted = false;
+
+    gst_query_parse_accept_caps (query, &caps);
+    GST_DEBUG_OBJECT(sink, "accept caps %" GST_PTR_FORMAT, caps);
+    GstStructure *caps_structure = gst_caps_get_structure(caps, 0);
+
+    const gchar * stream_format = gst_structure_get_name(caps_structure);
+    if(g_strrstr(stream_format,"video/x-h264")){
+        accepted = true;
+    }else if(g_strrstr(stream_format,"video/x-h265")){
+        accepted = true;
+    }else if(g_strrstr(stream_format,"video/x-vp9")){
+        accepted = true;
+    }else if(g_strrstr(stream_format,"video/x-vp8")){
+        accepted = true;
+    }
+    gst_query_set_accept_caps_result(query, accepted);
+}
+
+void gst_westeros_sink_soc_set_startPTS( GstWesterosSink *sink, gint64 pts )
+{
+    HRESULT ret;
+    Gstampvsink * amp_sink = &(sink->soc.amp_sink);
+    AVRational new_base;
+    AVRational time_base;
+    AMP_PTS pts_t;
+
+    new_base.num = 1;
+    new_base.den = 90000;
+    time_base.num=1;
+    time_base.den=1000000000;
+    if (pts != AV_NOPTS_VALUE && pts >= 0) {
+        pts = av_rescale_q(pts,time_base,new_base);
+    }
+    if (pts == AV_NOPTS_VALUE || pts < 0) {
+        pts &= ~(AMP_PTS_VALID_MASK);
+    } else {
+        pts |= AMP_PTS_VALID_MASK;
+    }
+
+
+    pts_t = pts;
+    AMP_RPC(ret, AMP_CLK_SetStartPTS, amp_sink->hClk, AMP_CLK_PORT_IRRELEVANT, pts_t);
+    VERIFY_RESULT(ret);
+    GST_DEBUG_OBJECT(sink, "set start pts: %llx", pts_t);
+}
+
+void gst_westeros_sink_soc_render( GstWesterosSink *sink, GstBuffer *buffer )
+{
+    //TBD
+}
+
+void gst_westeros_sink_soc_flush( GstWesterosSink *sink )
+{
+}
+
+gboolean gst_westeros_sink_soc_start_video( GstWesterosSink *sink )
+{
+    gboolean result= FALSE;
+    return result;
+}
+
+void gst_westeros_sink_soc_eos_event( GstWesterosSink *sink )
+{
+    Gstampvsink * amp_sink = &(sink->soc.amp_sink);
+    GstBuffer *endbuf;
+    endbuf = gst_buffer_new();
+    GST_BUFFER_OFFSET_END(endbuf)  = 1;
+    GST_BUFFER_OFFSET(endbuf) = 0;
+
+    //Need stream lock to sync with chain
+    GST_PAD_STREAM_LOCK(amp_sink->sinkpad);
+    feed_thread_push(amp_sink, endbuf);
+    GST_PAD_STREAM_UNLOCK(amp_sink->sinkpad);
+}
+
+void gst_westeros_sink_soc_set_video_path( GstWesterosSink *sink, bool useGfxPath )
+{
+    WESTEROS_UNUSED(sink);
+    WESTEROS_UNUSED(useGfxPath);
+}
+
+void gst_westeros_sink_soc_update_video_position( GstWesterosSink *sink )
+{
+    WESTEROS_UNUSED(sink);
+}
+
+void gst_westeros_sink_soc_load()
+{
+    MV_OSAL_Init();
+    AMP_Initialize(0, NULL, &hFactory);
+}
diff --git a/syna/westeros-sink/westeros-sink-soc.h b/syna/westeros-sink/westeros-sink-soc.h
new file mode 100644
index 0000000..7f1999f
--- /dev/null
+++ b/syna/westeros-sink/westeros-sink-soc.h
@@ -0,0 +1,189 @@
+/*
+ * If not stated otherwise in this file or this component's Licenses.txt file the
+ * following copyright and licenses apply:
+ *
+ * Copyright 2016 RDK Management
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#ifndef __WESTEROS_SINK_SOC_H__
+#define __WESTEROS_SINK_SOC_H__
+
+#include <stdlib.h>
+#include <libavformat/avformat.h>
+#include <libavcodec/avcodec.h>
+
+#include "simplebuffer-client-protocol.h"
+
+#include "OSAL_api.h"
+#include "amp_client.h"
+
+#define DEFAULT_PROP_RECTANGLE                          "0,0,0,0"
+#define DEFAULT_PROP_FLUSH_REPEAT_FRAME         0
+#define DEFAULT_PROP_CURRENT_PTS                        0
+#define DEFAULT_PROP_INTER_FRAME_DELAY          0
+#define DEFAULT_PROP_SLOW_MODE_RATE             5000
+#define DEFAULT_PROP_STEP_FRAME                         3003
+#define DEFAULT_PROP_COUNTER_FRAME_RATE         3003
+#define DEFAULT_PROP_MUTE                                       1
+#define DEFAULT_PROP_ZOOM                   1
+#define DEFAULT_PLAY_SPEED                      1
+
+#define WESTEROS_SINK_CAPS "video/x-tbd;"
+
+typedef struct _Gstampvsink      Gstampvsink;
+
+typedef enum
+{
+        DISP_PLANE_MAIN,
+        DISP_PLANE_PIP,
+        DISP_PLANE_GFX0,
+        DISP_PLANE_GFX1,
+        DISP_PLANE_GFX2,
+        DISP_PLANE_PG,
+        DISP_PLANE_BG,
+        DISP_PLANE_AUX,
+        DISP_PLANE_MAX
+}GstAmpPlane;
+
+
+typedef enum
+{
+    DISP_OUT_RES_NTSC_M ,
+    DISP_OUT_RES_480P60 ,
+    DISP_OUT_RES_PAL_M  ,
+    DISP_OUT_RES_PAL_BGH ,
+    DISP_OUT_RES_720P60 ,
+    DISP_OUT_RES_720P50 ,
+    DISP_OUT_RES_1080I60,
+    DISP_OUT_RES_1080I50,
+    DISP_OUT_RES_1080P60,
+    DISP_OUT_RES_1080P50
+
+}GstAmpTvMode;
+
+/* Definition of structure storing data for Gstampvsink element */
+struct _Gstampvsink
+{
+    AMP_FACTORY factory;
+    /* disp related */
+    AMP_DISP Disp;
+    AMP_DISP_ZORDER Zorder;
+    AMP_DISP_WIN SrcWin;
+    AMP_DISP_WIN DstWin;
+
+    gint plane;
+    gint tvmode;
+    gboolean repeatframe;
+    gulong currentpts;
+    guint framedelay;
+    gint slowmoderate;
+    guint contentframerate;
+    guint steprate;
+    guint mute;
+    guint zoom;
+    gboolean is_zoomSet;
+    gint64 current_time;
+    gint64 stream_duration;
+    gint64 tempTime;
+    gfloat play_speed;
+    gboolean m_isPaused;
+    gint64 timeDiff;
+    guint resolution;
+
+    GstPad *sinkpad ;
+    gboolean pipeline_created;
+
+    GThread *feed_t;
+    GCond   feed_cond;
+    GMutex  feed_mutex;
+    GQueue*  buf_q;
+    gboolean stop;
+
+    /* vout related begin */
+    AMP_COMPONENT hVout;
+    AMP_COMPONENT hClk;
+    HANDLE hVListener;
+    GstWesterosSink* westeros_sink;
+    gboolean is_eos;
+    /* vout related end */
+
+    /* vdec related begin */
+    GstCaps *cap_accepted;
+    AMP_COMPONENT hVdec;
+    /* secure pipeline */
+    BOOL        secure;
+
+    /* for clear stream*/
+    UINT32 shm_v;
+    UINT8  *addr_v;
+    UINT32 wp_v;
+    UINT32 rp_v;
+
+    UINT32 stream_pos;
+    UINT32 video_codec;
+    AMP_BDCHAIN *video_stream_queue;
+    HANDLE hVdecListener;
+
+    /* ES meta data from container */
+    UINT8 *codec_data;
+    UINT  codec_size;
+
+    /* ES header */
+    UINT8  video_priv_data[2048];
+    UINT32 video_priv_len;
+    gboolean video_priv_done;
+    /* H265 specific */
+    UINT32 nal_len_size;
+    /* vdec related end */
+};
+
+struct _GstWesterosSinkSoc
+{
+   Gstampvsink amp_sink;
+   struct wl_sb *sb;
+   int activeBuffers;
+};
+
+void gst_westeros_sink_soc_load();
+void gst_westeros_sink_soc_class_init(GstWesterosSinkClass *klass);
+gboolean gst_westeros_sink_soc_init( GstWesterosSink *sink );
+void gst_westeros_sink_soc_term( GstWesterosSink *sink );
+void gst_westeros_sink_soc_set_property(GObject *object, guint prop_id, const GValue *value, GParamSpec *pspec);
+void gst_westeros_sink_soc_get_property(GObject *object, guint prop_id, GValue *value, GParamSpec *pspec);
+gboolean gst_westeros_sink_soc_query(GstWesterosSink *sink, GstQuery * query);
+gboolean gst_westeros_sink_soc_null_to_ready( GstWesterosSink *sink, gboolean *passToDefault );
+gboolean gst_westeros_sink_soc_ready_to_paused( GstWesterosSink *sink, gboolean *passToDefault );
+gboolean gst_westeros_sink_soc_paused_to_playing( GstWesterosSink *sink, gboolean *passToDefault );
+gboolean gst_westeros_sink_soc_playing_to_paused( GstWesterosSink *sink, gboolean *passToDefault );
+gboolean gst_westeros_sink_soc_paused_to_ready( GstWesterosSink *sink, gboolean *passToDefault );
+gboolean gst_westeros_sink_soc_ready_to_null( GstWesterosSink *sink, gboolean *passToDefault );
+void gst_westeros_sink_soc_registryHandleGlobal( GstWesterosSink *sink, 
+                                 struct wl_registry *registry, uint32_t id,
+		                           const char *interface, uint32_t version);
+void gst_westeros_sink_soc_registryHandleGlobalRemove(GstWesterosSink *sink,
+                                 struct wl_registry *registry,
+			                        uint32_t name);
+gboolean gst_westeros_sink_soc_accept_caps( GstWesterosSink *sink, GstCaps *caps );
+void gst_westeros_sink_soc_set_startPTS( GstWesterosSink *sink, gint64 pts );
+void gst_westeros_sink_soc_render( GstWesterosSink *sink, GstBuffer *buffer );
+void gst_westeros_sink_soc_flush( GstWesterosSink *sink );
+gboolean gst_westeros_sink_soc_start_video( GstWesterosSink *sink );
+void gst_westeros_sink_soc_eos_event( GstWesterosSink *sink );
+void gst_westeros_sink_soc_set_video_path( GstWesterosSink *sink, bool useGfxPath );
+void gst_westeros_sink_soc_update_video_position( GstWesterosSink *sink );
+void gst_westeros_sink_soc_query_caps(GstWesterosSink *sink, GstQuery *query);
+void gst_westeros_sink_soc_query_accept_caps(GstWesterosSink *sink, GstQuery *query);
+
+#endif
+
diff --git a/syna/westeros-sink/westeros-sink.c b/syna/westeros-sink/westeros-sink.c
new file mode 100644
index 0000000..291fab6
--- /dev/null
+++ b/syna/westeros-sink/westeros-sink.c
@@ -0,0 +1,1238 @@
+/*
+ * If not stated otherwise in this file or this component's Licenses.txt file the
+ * following copyright and licenses apply:
+ *
+ * Copyright 2016 RDK Management
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <string.h>
+#include <stdio.h>
+
+#include "westeros-sink.h"
+
+#define GST_PACKAGE_ORIGIN "http://gstreamer.net/"
+
+static GstStaticPadTemplate gst_westeros_sink_pad_template =
+GST_STATIC_PAD_TEMPLATE ("sink",
+    GST_PAD_SINK,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS(WESTEROS_SINK_CAPS));
+
+GST_DEBUG_CATEGORY (gst_westeros_sink_debug);
+#define GST_CAT_DEFAULT gst_westeros_sink_debug
+
+enum
+{
+  PROP_0,
+  PROP_WINDOW_SET,
+  PROP_ZORDER,
+  PROP_OPACITY
+};
+
+#ifdef USE_GST1
+#define gst_westeros_sink_parent_class parent_class
+G_DEFINE_TYPE (GstWesterosSink, gst_westeros_sink, GST_TYPE_ELEMENT)
+#else
+GST_BOILERPLATE (GstWesterosSink, gst_westeros_sink, GstBaseSink, GST_TYPE_BASE_SINK)
+#endif
+
+static void gst_westeros_sink_term(GstWesterosSink *sink); 
+static void gst_westeros_sink_finalize(GObject *object); 
+static void gst_westeros_sink_set_property(GObject *object, guint prop_id, const GValue *value, GParamSpec *pspec);
+static void gst_westeros_sink_get_property(GObject *object, guint prop_id, GValue *value, GParamSpec *pspec);
+static GstStateChangeReturn gst_westeros_sink_change_state(GstElement *element, GstStateChange transition);
+static gboolean gst_westeros_sink_query(GstElement *element, GstQuery *query);
+static gboolean gst_westeros_sink_start(GstBaseSink *base_sink);
+static gboolean gst_westeros_sink_stop(GstBaseSink *base_sink);
+static gboolean gst_westeros_sink_unlock(GstBaseSink *base_sink);
+static gboolean gst_westeros_sink_unlock_stop(GstBaseSink *base_sink);
+static gboolean gst_westeros_sink_check_caps(GstWesterosSink *sink, GstPad *peer);
+#ifdef USE_GST1
+static gboolean gst_westeros_sink_event(GstPad *pad, GstObject *parent, GstEvent *event);
+static GstPadLinkReturn gst_westeros_sink_link(GstPad *pad, GstObject *parent, GstPad *peer);
+static void gst_westeros_sink_unlink(GstPad *pad, GstObject *parent);
+//static gboolean gst_westeros_sink_sink_query(GstPad *pad, GstObject *parent, GstQuery *query);
+#else
+static gboolean gst_westeros_sink_event(GstPad *pad, GstEvent *event);
+static GstPadLinkReturn gst_westeros_sink_link(GstPad *pad, GstPad *peer);
+static void gst_westeros_sink_unlink(GstPad *pad);
+//static gboolean gst_westeros_sink_sink_query(GstPad *pad, GstQuery *query);
+#endif
+static GstFlowReturn gst_westeros_sink_render(GstBaseSink *base_sink, GstBuffer *buffer);
+static GstFlowReturn gst_westeros_sink_preroll(GstBaseSink *base_sink, GstBuffer *buffer);
+
+
+static void shellSurfaceId(void *data,
+                           struct wl_simple_shell *wl_simple_shell,
+                           struct wl_surface *surface,
+                           uint32_t surfaceId)
+{
+   GstWesterosSink *sink= (GstWesterosSink*)data;
+   sink->surfaceId= surfaceId;
+   char name[32];
+   wl_fixed_t z, op;
+   WESTEROS_UNUSED(wl_simple_shell);
+   WESTEROS_UNUSED(surface);
+
+	sprintf( name, "westeros-sink-surface-%x", surfaceId );	
+	wl_simple_shell_set_name( sink->shell, surfaceId, name );
+   if ( (sink->windowWidth == 0) || (sink->windowHeight == 0) )
+   {
+      wl_simple_shell_set_visible( sink->shell, sink->surfaceId, false);
+   }
+   else
+   {
+      z= wl_fixed_from_double(sink->zorder);
+      wl_simple_shell_set_zorder( sink->shell, sink->surfaceId, z);
+      op= wl_fixed_from_double(sink->opacity);
+      wl_simple_shell_set_opacity( sink->shell, sink->surfaceId, op);
+      wl_simple_shell_get_status( sink->shell, sink->surfaceId );
+   }
+   wl_display_flush(sink->display);
+}                           
+
+static void shellSurfaceCreated(void *data,
+                                struct wl_simple_shell *wl_simple_shell,
+                                uint32_t surfaceId,
+                                const char *name)
+{
+   WESTEROS_UNUSED(data);
+   WESTEROS_UNUSED(wl_simple_shell);
+   WESTEROS_UNUSED(surfaceId);
+   WESTEROS_UNUSED(name);
+}
+                                
+static void shellSurfaceDestroyed(void *data,
+                                  struct wl_simple_shell *wl_simple_shell,
+                                  uint32_t surfaceId,
+                                  const char *name)
+{
+   WESTEROS_UNUSED(data);
+   WESTEROS_UNUSED(wl_simple_shell);
+   WESTEROS_UNUSED(surfaceId);
+   WESTEROS_UNUSED(name);
+}
+                                  
+static void shellSurfaceStatus(void *data,
+                               struct wl_simple_shell *wl_simple_shell,
+                               uint32_t surfaceId,
+                               const char *name,
+                               uint32_t visible,
+                               int32_t x,
+                               int32_t y,
+                               int32_t width,
+                               int32_t height,
+                               wl_fixed_t opacity,
+                               wl_fixed_t zorder)
+{
+   GstWesterosSink *sink= (GstWesterosSink*)data;
+   WESTEROS_UNUSED(wl_simple_shell);
+   WESTEROS_UNUSED(surfaceId);
+   WESTEROS_UNUSED(name);
+   WESTEROS_UNUSED(x);
+   WESTEROS_UNUSED(y);
+   WESTEROS_UNUSED(width);
+   WESTEROS_UNUSED(height);
+   sink->visible= visible;
+   sink->windowChange= true;
+   sink->opacity= opacity;
+   sink->zorder= zorder;
+}
+
+static void shellGetSurfacesDone(void *data, struct wl_simple_shell *wl_simple_shell )
+{
+   WESTEROS_UNUSED(data);
+   WESTEROS_UNUSED(wl_simple_shell);
+}
+
+static const struct wl_simple_shell_listener shellListener = 
+{
+   shellSurfaceId,
+   shellSurfaceCreated,
+   shellSurfaceDestroyed,
+   shellSurfaceStatus,
+   shellGetSurfacesDone
+};
+
+static void vpcVideoPathChange(void *data,
+                               struct wl_vpc_surface *wl_vpc_surface,
+                               uint32_t new_pathway )
+{
+   WESTEROS_UNUSED(wl_vpc_surface);
+   GstWesterosSink *sink= (GstWesterosSink*)data;
+   printf("westeros-sink: new pathway: %d\n", new_pathway);
+   gst_westeros_sink_soc_set_video_path( sink, (new_pathway == WL_VPC_SURFACE_PATHWAY_GRAPHICS) );
+}                               
+
+static void vpcVideoXformChange(void *data,
+                                struct wl_vpc_surface *wl_vpc_surface,
+                                int32_t x_translation,
+                                int32_t y_translation,
+                                uint32_t x_scale_num,
+                                uint32_t x_scale_denom,
+                                uint32_t y_scale_num,
+                                uint32_t y_scale_denom,
+                                uint32_t output_width,
+                                uint32_t output_height)
+{                                
+   WESTEROS_UNUSED(wl_vpc_surface);
+   GstWesterosSink *sink= (GstWesterosSink*)data;
+      
+   sink->transX= x_translation;
+   sink->transY= y_translation;
+   if ( x_scale_denom )
+   {
+      sink->scaleXNum= x_scale_num;
+      sink->scaleXDenom= x_scale_denom;
+   }
+   if ( y_scale_denom )
+   {
+      sink->scaleYNum= y_scale_num;
+      sink->scaleYDenom= y_scale_denom;
+   }
+   sink->outputWidth= (int)output_width;
+   sink->outputHeight= (int)output_height;
+   
+   LOCK( sink );
+   gst_westeros_sink_soc_update_video_position( sink );
+   UNLOCK( sink );
+}
+
+static const struct wl_vpc_surface_listener vpcListener= {
+   vpcVideoPathChange,
+   vpcVideoXformChange
+};
+
+static void registryHandleGlobal(void *data, 
+                                 struct wl_registry *registry, uint32_t id,
+		                           const char *interface, uint32_t version);
+static void registryHandleGlobalRemove(void *data, 
+                                       struct wl_registry *registry,
+			                              uint32_t name);
+
+static const struct wl_registry_listener registryListener = 
+{
+	registryHandleGlobal,
+	registryHandleGlobalRemove
+};
+
+static void registryHandleGlobal(void *data, 
+                                 struct wl_registry *registry, uint32_t id,
+		                           const char *interface, uint32_t version)
+{
+   GstWesterosSink *sink= (GstWesterosSink*)data;
+   int len;
+
+   printf("westeros-sink: registry: id %d interface (%s) version %d\n", id, interface, version );
+   
+   len= strlen(interface);
+   if ((len==13) && (strncmp(interface, "wl_compositor",len) == 0)) 
+   {
+      sink->compositor= (struct wl_compositor*)wl_registry_bind(registry, id, &wl_compositor_interface, 1);
+      printf("westeros-sink: compositor %p\n", (void*)sink->compositor);
+      wl_proxy_set_queue((struct wl_proxy*)sink->compositor, sink->queue);
+   }
+   else if ((len==15) && (strncmp(interface, "wl_simple_shell",len) == 0)) 
+   {
+      sink->shell= (struct wl_simple_shell*)wl_registry_bind(registry, id, &wl_simple_shell_interface, 1);
+      printf("westeros-sink: shell %p\n", (void*)sink->shell);
+      wl_proxy_set_queue((struct wl_proxy*)sink->shell, sink->queue);
+      wl_simple_shell_add_listener(sink->shell, &shellListener, sink);
+   }
+   else if ((len==6) && (strncmp(interface, "wl_vpc", len) ==0))
+   {
+      sink->vpc= (struct wl_vpc*)wl_registry_bind(registry, id, &wl_vpc_interface, 1);
+      printf("westeros-sink: registry: vpc %p\n", (void*)sink->vpc);
+      wl_proxy_set_queue((struct wl_proxy*)sink->vpc, sink->queue);
+   }
+   
+   gst_westeros_sink_soc_registryHandleGlobal( sink, registry, id, interface, version );
+
+   wl_display_flush(sink->display);
+}
+
+static void registryHandleGlobalRemove(void *data, 
+                                       struct wl_registry *registry,
+			                              uint32_t name)
+{
+   GstWesterosSink *sink= (GstWesterosSink*)data;
+
+   gst_westeros_sink_soc_registryHandleGlobalRemove( sink, registry, name );
+}
+
+
+#ifndef USE_GST1
+static void gst_westeros_sink_base_init(gpointer g_class)
+{
+  GstElementClass *gstelement_class = GST_ELEMENT_CLASS (g_class);
+
+  GST_DEBUG_CATEGORY_INIT (gst_westeros_sink_debug, "westerossink", 0, "westerossink element");
+
+  gst_element_class_add_pad_template (gstelement_class,
+      gst_static_pad_template_get (&gst_westeros_sink_pad_template));
+  gst_element_class_set_details_simple (gstelement_class, "Westeros Sink",
+      "Video Sink",
+      "Writes buffers to the westeros wayland compositor",
+      "Comcast");
+}
+#endif
+
+static void gst_westeros_sink_class_init(GstWesterosSinkClass *klass)
+{
+   GObjectClass *gobject_class= (GObjectClass *) klass;
+   GstElementClass *gstelement_class= (GstElementClass *) klass;
+   
+   gobject_class->finalize= gst_westeros_sink_finalize;
+   gobject_class->set_property= gst_westeros_sink_set_property;
+   gobject_class->get_property= gst_westeros_sink_get_property;
+   
+   gstelement_class->change_state= gst_westeros_sink_change_state;
+   gstelement_class->query= gst_westeros_sink_query;
+#if 0
+   GstBaseSinkClass *gstbasesink_class= (GstBaseSinkClass *) klass;
+   gstbasesink_class->start= GST_DEBUG_FUNCPTR (gst_westeros_sink_start);
+   gstbasesink_class->stop= GST_DEBUG_FUNCPTR (gst_westeros_sink_stop);
+   gstbasesink_class->unlock= GST_DEBUG_FUNCPTR (gst_westeros_sink_unlock);
+   gstbasesink_class->unlock_stop= GST_DEBUG_FUNCPTR (gst_westeros_sink_unlock_stop);
+   gstbasesink_class->render= GST_DEBUG_FUNCPTR (gst_westeros_sink_render);
+   gstbasesink_class->preroll= GST_DEBUG_FUNCPTR (gst_westeros_sink_preroll);
+#endif
+   klass->sink_cb = gst_westeros_sink_event;
+
+   g_object_class_install_property (G_OBJECT_CLASS (klass), PROP_WINDOW_SET,
+       g_param_spec_string ("window_set", "window set",
+           "Window Set Format: x,y,width,height",
+           NULL, G_PARAM_WRITABLE));
+
+   g_object_class_install_property (G_OBJECT_CLASS (klass), PROP_WINDOW_SET,
+       g_param_spec_string ("rectangle", "rectangle",
+           "Window Set Format: x,y,width,height",
+           NULL, G_PARAM_WRITABLE));
+
+   g_object_class_install_property (G_OBJECT_CLASS (klass), PROP_ZORDER,
+       g_param_spec_float ("zorder", "zorder",
+           "zorder from 0.0 (lowest) to 1.0 (highest)",
+           0.0, 1.0, 0.0, G_PARAM_WRITABLE));
+
+   g_object_class_install_property (G_OBJECT_CLASS (klass), PROP_OPACITY,
+       g_param_spec_float ("opacity", "opacity",
+           "opacity from 0.0 (transparent) to 1.0 (opaque)",
+           0.0, 1.0, 1.0, G_PARAM_WRITABLE));
+
+#ifdef USE_GST1
+  GST_DEBUG_CATEGORY_INIT (gst_westeros_sink_debug, "westerossink", 0, "westerossink element");
+
+  gst_element_class_add_pad_template (gstelement_class,
+      gst_static_pad_template_get (&gst_westeros_sink_pad_template));
+  gst_element_class_set_details_simple (gstelement_class, "Westeros Sink",
+      "Video Sink",
+      "Writes buffers to the westeros wayland compositor",
+      "Synaptics");
+#endif
+
+   gst_westeros_sink_soc_class_init(klass);
+}
+
+static void 
+#ifdef USE_GST1
+gst_westeros_sink_init(GstWesterosSink *sink)
+{
+#else
+gst_westeros_sink_init(GstWesterosSink *sink, GstWesterosSinkClass *gclass) 
+{
+   WESTEROS_UNUSED(gclass);
+#endif
+   
+   sink->peerPad= NULL;
+   
+#if 0
+   sink->parentEventFunc = GST_PAD_EVENTFUNC(GST_BASE_SINK_PAD(sink));
+   sink->defaultQueryFunc = GST_PAD_QUERYFUNC(GST_BASE_SINK_PAD(sink));
+   if ( sink->defaultQueryFunc == NULL )
+   {
+      sink->defaultQueryFunc= gst_pad_query_default;
+   }
+
+
+   gst_pad_set_event_function(GST_BASE_SINK_PAD(sink), GST_DEBUG_FUNCPTR(gst_westeros_sink_event));
+   gst_pad_set_link_function(GST_BASE_SINK_PAD(sink), GST_DEBUG_FUNCPTR(gst_westeros_sink_link));
+   gst_pad_set_unlink_function(GST_BASE_SINK_PAD(sink), GST_DEBUG_FUNCPTR(gst_westeros_sink_unlink));
+   gst_pad_set_query_function(GST_BASE_SINK_PAD(sink), GST_DEBUG_FUNCPTR(gst_westeros_sink_sink_query));
+    
+   gst_base_sink_set_sync(GST_BASE_SINK(sink), FALSE);
+   gst_base_sink_set_async_enabled(GST_BASE_SINK(sink), FALSE);
+#endif
+
+   sink->initialized= TRUE;
+   
+   #ifdef GLIB_VERSION_2_32 
+   g_mutex_init( &sink->mutex );
+   #else
+   sink->mutex= g_mutex_new();
+   #endif
+
+   sink->videoStarted= FALSE;
+   sink->startAfterLink= FALSE;	
+   sink->flushStarted= FALSE;
+   sink->rejectPrerollBuffers= FALSE;
+   
+   sink->srcWidth= 1280;
+   sink->srcHeight= 720;
+   sink->maxWidth= 3840;
+   sink->maxHeight= 2160;
+
+   sink->windowX= DEFAULT_WINDOW_X;
+   sink->windowY= DEFAULT_WINDOW_Y;
+   sink->windowWidth= DEFAULT_WINDOW_WIDTH;
+   sink->windowHeight= DEFAULT_WINDOW_HEIGHT;
+   sink->windowChange= false;
+   sink->windowSizeOverride= false;
+   
+   sink->visible= false;
+   
+   sink->opacity= 1.0;
+   sink->zorder= 0.0;
+
+   sink->transX= 0;
+   sink->transY= 0;
+   sink->scaleXNum= 1;
+   sink->scaleXDenom= 1;
+   sink->scaleYNum= 1;
+   sink->scaleYDenom= 1;
+   sink->outputWidth= DEFAULT_WINDOW_WIDTH;
+   sink->outputHeight= DEFAULT_WINDOW_HEIGHT;
+   
+   sink->eosEventSeen= FALSE;
+   sink->eosDetected= FALSE;
+   sink->startPTS= 0;
+   sink->firstPTS= 0;
+   sink->currentPTS= 0;
+   sink->position= 0;
+   sink->positionSegmentStart= 0;
+   sink->prevPositionSegmentStart= 0;
+   sink->segmentNumber= 0;
+   sink->queryPositionFromPeer= FALSE;
+
+   sink->display= 0;
+   sink->currentSegment = NULL;
+
+   if ( gst_westeros_sink_soc_init( sink ) == TRUE )
+   {
+      sink->display= 0;
+      sink->registry= 0;
+      sink->shell= 0;
+      sink->compositor= 0;
+      sink->surfaceId= 0;
+      sink->vpc= 0;
+      sink->vpcSurface= 0;
+
+      if ( !sink->display ) 
+      {
+         sink->display= wl_display_connect(NULL);
+      }
+
+      if ( sink->display )
+      {
+         sink->queue= wl_display_create_queue(sink->display);
+         if ( sink->queue )
+         {
+            sink->registry= wl_display_get_registry( sink->display );
+            if ( sink->registry )
+            {
+               wl_proxy_set_queue((struct wl_proxy*)sink->registry, sink->queue);
+               wl_registry_add_listener(sink->registry, &registryListener, sink);   
+               wl_display_roundtrip_queue(sink->display,sink->queue);
+               
+               sink->surface= wl_compositor_create_surface(sink->compositor);
+               printf("gst_westeros_sink_init: surface=%p\n", (void*)sink->surface);
+               wl_proxy_set_queue((struct wl_proxy*)sink->surface, sink->queue);
+               
+               wl_display_flush( sink->display );
+            }
+            else
+            {
+               GST_ERROR("gst_westeros_sink_init: unable to get display registry\n");
+            }
+         }
+         else
+         {
+            GST_ERROR("gst_westeros_sink_init: unable to create queue\n");
+         }
+      }
+      else
+      {
+         GST_ERROR("gst_westeros_sink_init: unable to create display\n");
+      }
+   }
+   else
+   {
+      GST_ERROR("gst_westeros_sink_init: soc_init failed\n");
+   }
+}
+
+static void gst_westeros_sink_term(GstWesterosSink *sink)
+{
+   sink->initialized= FALSE;
+   
+   gst_westeros_sink_soc_term( sink );
+   
+   if ( sink->vpc )
+   {
+      wl_vpc_destroy( sink->vpc );
+      sink->vpc= 0;
+   }   
+   if ( sink->surface )
+   {
+      wl_surface_destroy( sink->surface );
+      sink->surface= 0;
+   }
+   if ( sink->compositor )
+   {
+      wl_compositor_destroy( sink->compositor );
+      sink->compositor= 0;
+   }
+   if ( sink->shell )
+   {
+      wl_simple_shell_destroy( sink->shell );
+      sink->shell= 0;
+   }
+   if ( sink->registry )
+   {
+      wl_registry_destroy(sink->registry);
+      sink->registry= 0;
+   }
+   if ( sink->queue )
+   {
+      wl_event_queue_destroy( sink->queue );
+      sink->queue= 0;
+   }
+   if ( sink->display )
+   {
+      printf("gst_westeros_sink_term: wl_display_disconnect: display=%p\n", (void*)sink->display);
+      wl_display_disconnect(sink->display);
+      sink->display= 0;
+   }
+   
+   #ifdef GLIB_VERSION_2_32 
+   g_mutex_clear( &sink->mutex );
+   #else
+   g_mutex_free( sink->mutex );
+   #endif  
+}
+
+static void gst_westeros_sink_finalize(GObject *object) 
+{
+   GstWesterosSink *sink = GST_WESTEROS_SINK(object);
+
+   if ( sink->initialized )
+   {
+      gst_westeros_sink_term( sink );
+   }
+
+   GST_CALL_PARENT (G_OBJECT_CLASS, finalize, (object));
+   GST_DEBUG("gst_westeros_sink_finalize");
+}
+
+static void gst_westeros_sink_set_property(GObject *object, guint prop_id, const GValue *value, GParamSpec *pspec) 
+{
+   GstWesterosSink *sink = GST_WESTEROS_SINK(object);
+  
+   WESTEROS_UNUSED(pspec);
+   WESTEROS_UNUSED(value);
+   WESTEROS_UNUSED(sink);
+    
+   switch (prop_id) 
+   {
+      case PROP_WINDOW_SET:
+      {
+         const gchar *str= g_value_get_string(value);
+         gchar **parts= g_strsplit(str, ",", 4);
+         
+         if ( !parts[0] || !parts[1] || !parts[2] || !parts[3] )
+         {
+            GST_ERROR( "Bad window properties string" );
+         }
+         else
+         {
+            LOCK( sink );
+            sink->windowChange= true;
+            sink->windowX= atoi( parts[0] );
+            sink->windowY= atoi( parts[1] );
+            sink->windowWidth= atoi( parts[2] );
+            sink->windowHeight= atoi( parts[3] );
+            if ( (sink->windowWidth != DEFAULT_WINDOW_WIDTH) ||
+                 (sink->windowHeight != DEFAULT_WINDOW_HEIGHT) )
+            {
+               sink->windowSizeOverride= true;
+            }    
+            UNLOCK( sink );
+
+            printf("gst_westeros_sink_set_property set window rect (%d,%d,%d,%d)\n",
+                    sink->windowX, sink->windowY, sink->windowWidth, sink->windowHeight );
+
+            if ( sink->vpcSurface )
+            {
+               if ( sink->vpcSurface )
+               {
+                  wl_vpc_surface_set_geometry( sink->vpcSurface, sink->windowX, sink->windowY, sink->windowWidth, sink->windowHeight );
+               }
+            }
+
+            if ( sink->shell && sink->surfaceId )
+            {
+               if ( (sink->windowWidth > 0) && (sink->windowHeight > 0 ) )
+               {
+                  wl_simple_shell_set_visible( sink->shell, sink->surfaceId, true);
+                  
+                  wl_simple_shell_get_status( sink->shell, sink->surfaceId);
+                  
+                  wl_display_flush( sink->display );
+               }
+            }            
+                    
+            sink->srcWidth= sink->windowWidth;
+            sink->srcHeight= sink->windowHeight;
+         }
+
+         g_strfreev(parts);
+         break;
+      }
+      
+      case PROP_ZORDER:
+      {
+         sink->zorder= g_value_get_float(value);
+         if ( sink->shell )
+         {
+            wl_fixed_t z= wl_fixed_from_double(sink->zorder);
+            wl_simple_shell_set_zorder( sink->shell, sink->surfaceId, z);
+         }
+         break;
+      }
+      
+      case PROP_OPACITY:
+      {
+         sink->opacity= g_value_get_float(value);
+         if ( sink->shell )
+         {
+            wl_fixed_t op= wl_fixed_from_double(sink->opacity);
+            wl_simple_shell_set_opacity( sink->shell, sink->surfaceId, op);
+         }
+         break;
+      }
+      
+      default:
+         gst_westeros_sink_soc_set_property(object, prop_id, value, pspec);
+         break;
+   }
+}
+
+static void gst_westeros_sink_get_property(GObject *object, guint prop_id, GValue *value, GParamSpec *pspec) 
+{
+   GstWesterosSink *sink = GST_WESTEROS_SINK(object);
+  
+   WESTEROS_UNUSED(pspec); 
+   WESTEROS_UNUSED(value);
+   WESTEROS_UNUSED(sink);
+    
+   switch (prop_id) 
+   {      
+      default:
+         gst_westeros_sink_soc_get_property(object, prop_id, value, pspec);
+         break;
+   }
+}
+
+static GstStateChangeReturn gst_westeros_sink_change_state(GstElement *element, GstStateChange transition)
+{
+   GstStateChangeReturn result= GST_STATE_CHANGE_SUCCESS;
+   GstWesterosSink *sink= GST_WESTEROS_SINK(element);
+   gboolean passToDefault= true;
+
+   GST_DEBUG_OBJECT(element, "westeros-sink: change state from %s to %s\n", 
+      gst_element_state_get_name (GST_STATE_TRANSITION_CURRENT (transition)),
+      gst_element_state_get_name (GST_STATE_TRANSITION_NEXT (transition)));
+
+   sink->rejectPrerollBuffers= false;
+
+   if (GST_STATE_TRANSITION_CURRENT(transition) == GST_STATE_TRANSITION_NEXT(transition))
+   {
+      return GST_STATE_CHANGE_SUCCESS;
+   }
+
+   switch (transition) 
+   {
+      case GST_STATE_CHANGE_NULL_TO_READY:
+      {
+         sink->position= 0;         
+         sink->eosDetected= FALSE;
+         sink->eosEventSeen= FALSE;
+
+         if ( sink->vpc && sink->surface )
+         {
+            sink->vpcSurface= wl_vpc_get_vpc_surface( sink->vpc, sink->surface );
+            if ( sink->vpcSurface )
+            {
+               wl_vpc_surface_add_listener( sink->vpcSurface, &vpcListener, sink );
+               wl_proxy_set_queue((struct wl_proxy*)sink->vpcSurface, sink->queue);
+               if ( (sink->windowWidth != DEFAULT_WINDOW_WIDTH) || (sink->windowHeight != DEFAULT_WINDOW_HEIGHT) )
+               {
+                  wl_vpc_surface_set_geometry( sink->vpcSurface, sink->windowX, sink->windowY, sink->windowWidth, sink->windowHeight );
+               }
+               wl_display_flush( sink->display );
+               printf("westeros-sink: null_to_ready: done add vpcSurface listener\n");
+            }
+            else
+            {
+               GST_ERROR("gst_westeros_sink: null_to_ready: failed to create vpcSurface\n");
+            }
+         }
+         else
+         {
+            GST_ERROR("gst_westeros_sink: null_to_ready: can't create vpc surface: vpc %p surface %p\n",
+                      sink->vpc, sink->surface);
+         }
+
+         if ( !gst_westeros_sink_soc_null_to_ready(sink, &passToDefault) )
+         {
+            result= GST_STATE_CHANGE_FAILURE;
+         }         
+         break;
+      }
+
+      case GST_STATE_CHANGE_READY_TO_PAUSED:
+      {
+         if ( gst_westeros_sink_soc_ready_to_paused(sink, &passToDefault) )
+         {
+#if 0
+            sink->rejectPrerollBuffers = !gst_base_sink_is_async_enabled(GST_BASE_SINK(sink));
+#endif
+         }
+         else
+         {
+            result= GST_STATE_CHANGE_FAILURE;
+         }
+         break;
+      }
+
+      case GST_STATE_CHANGE_PAUSED_TO_PLAYING:
+      {
+         if ( !gst_westeros_sink_soc_paused_to_playing( sink, &passToDefault) )
+         {
+            result= GST_STATE_CHANGE_FAILURE;
+         }
+         break;
+	   }
+
+      case GST_STATE_CHANGE_PLAYING_TO_PAUSED:
+      {
+         if ( gst_westeros_sink_soc_playing_to_paused( sink, &passToDefault ) )
+         {
+#if 0
+            sink->rejectPrerollBuffers = !gst_base_sink_is_async_enabled(GST_BASE_SINK(sink));
+#endif
+         }
+         break;
+      }
+
+      case GST_STATE_CHANGE_PAUSED_TO_READY:
+      {
+         sink->eosEventSeen= FALSE;
+         sink->eosDetected= FALSE;
+         if ( gst_westeros_sink_soc_paused_to_ready( sink, &passToDefault ) )
+         {
+#if 0
+            sink->rejectPrerollBuffers = !gst_base_sink_is_async_enabled(GST_BASE_SINK(sink));
+#endif
+         }
+         break;
+      }
+
+      case GST_STATE_CHANGE_READY_TO_NULL:
+      {
+         if ( sink->initialized )
+         {
+            if ( sink->vpcSurface )
+            {
+               wl_vpc_surface_destroy( sink->vpcSurface );
+               sink->vpcSurface= 0;
+            }
+
+            if ( !gst_westeros_sink_soc_ready_to_null( sink, &passToDefault ) )
+            {
+               result= GST_STATE_CHANGE_FAILURE;
+            }
+            gst_westeros_sink_term( sink );
+         }
+         break;
+      }
+
+      default:
+         break;
+   }
+  
+   if (result == GST_STATE_CHANGE_FAILURE)
+   {
+      return result;
+   }
+   
+   if ( passToDefault )
+   {
+      result= GST_ELEMENT_CLASS(parent_class)->change_state(element, transition);
+   }
+ 
+   return result;
+}
+
+static gboolean gst_westeros_sink_query(GstElement *element, GstQuery *query)
+{
+   GstWesterosSink *sink= GST_WESTEROS_SINK(element);
+
+   switch (GST_QUERY_TYPE(query)) 
+   {
+#if 0
+      case GST_QUERY_CAPS:
+      {
+          gst_westeros_sink_soc_query_caps(sink, query);
+          return TRUE;
+      }
+      case GST_QUERY_ACCEPT_CAPS:
+      {
+          gst_westeros_sink_soc_query_accept_caps(sink, query);
+          return TRUE;
+      }
+#endif
+      case GST_QUERY_LATENCY:
+         gst_query_set_latency(query, FALSE, 0, 10*1000*1000);
+         return TRUE;
+   
+      case GST_QUERY_POSITION:
+         {
+            GstFormat format;
+            
+            gst_query_parse_position(query, &format, NULL);
+            
+            if ( GST_FORMAT_BYTES == format )
+            {
+               return GST_ELEMENT_CLASS(parent_class)->query(element, query);
+            }
+            else
+            {
+               if (sink->queryPositionFromPeer && sink->peerPad)
+               {
+                   if (gst_pad_query(sink->peerPad, query))
+                   {
+                       GST_DEBUG_OBJECT(sink, "Queried position from peer");
+                       return TRUE;
+                   }
+               }
+               LOCK( sink );
+               gint64 position= sink->position;
+               UNLOCK( sink );
+               GST_DEBUG_OBJECT(sink, "POSITION: %" GST_TIME_FORMAT, GST_TIME_ARGS (position));
+               gst_query_set_position(query, GST_FORMAT_TIME, position);
+               return TRUE;
+            }
+         }
+         break;
+         
+      case GST_QUERY_CUSTOM:
+      case GST_QUERY_DURATION:
+      case GST_QUERY_SEEKING:
+      case GST_QUERY_RATE:
+         if (sink->peerPad)
+         {
+            return gst_pad_query(sink->peerPad, query);
+         }
+              
+      default:
+         return GST_ELEMENT_CLASS(parent_class)->query (element, query);
+   }
+}
+
+static gboolean gst_westeros_sink_start(GstBaseSink *base_sink)
+{
+   WESTEROS_UNUSED(base_sink);
+
+   return TRUE;
+}
+
+static gboolean gst_westeros_sink_stop(GstBaseSink *base_sink)
+{
+   WESTEROS_UNUSED(base_sink);
+
+   return TRUE;
+}
+
+static gboolean gst_westeros_sink_unlock(GstBaseSink *base_sink)
+{
+   WESTEROS_UNUSED(base_sink);
+  
+   return TRUE;
+}
+
+static gboolean gst_westeros_sink_unlock_stop(GstBaseSink *base_sink)
+{
+   WESTEROS_UNUSED(base_sink);
+
+   return TRUE;
+}
+
+#ifdef USE_GST1
+static gboolean gst_westeros_sink_event(GstPad *pad, GstObject *parent, GstEvent *event)
+{
+   GstWesterosSink *sink= GST_WESTEROS_SINK(parent);
+#else
+static gboolean gst_westeros_sink_event(GstPad *pad, GstEvent *event)
+{
+   GstWesterosSink *sink= GST_WESTEROS_SINK(gst_pad_get_parent(pad));
+#endif
+   gboolean result= TRUE;
+   //gboolean passToDefault= FALSE;
+
+   switch (GST_EVENT_TYPE(event))
+   {
+      case GST_EVENT_CAPS:
+         if (sink->maxWidth && sink->maxHeight)
+         {
+            GstCaps *caps;
+            gst_event_parse_caps(event, &caps);
+            GstStructure* structure = gst_caps_get_structure(caps, 0);
+            if (structure && (gst_structure_has_field(structure, "width") || gst_structure_has_field(structure, "height")))
+            {
+               gint width, height;
+               gst_structure_get_int(structure, "width", &width);
+               gst_structure_get_int(structure, "height", &height);
+               if (width > sink->maxWidth || height > sink->maxHeight)
+               {
+                  GST_ERROR("width=%d height=%d > maxWidth=%d maxHeight=%d\n", width, height, sink->maxWidth, sink->maxHeight);
+                  const char *err_string = "Maximum video dimensions exceeded";
+                  GError *error = g_error_new(GST_STREAM_ERROR, GST_STREAM_ERROR_WRONG_TYPE, "%s", err_string);
+                  GstMessage *message = gst_message_new_error(GST_OBJECT_CAST(sink), error, err_string);
+                  gst_element_post_message(GST_ELEMENT_CAST(sink), message);
+                  g_error_free(error);
+               }
+            }
+         }
+         gst_event_unref (event);
+         break;
+      case GST_EVENT_FLUSH_START:
+         LOCK( sink );
+         sink->position= 0;
+         sink->flushStarted= TRUE;
+         sink->currentPTS= 0;
+         UNLOCK( sink );
+         //passToDefault= TRUE;
+         gst_event_unref (event);
+         break;
+          
+      case GST_EVENT_EOS:
+         {
+            LOCK( sink );
+            gboolean eosDetected= sink->eosDetected;
+            sink->eosEventSeen= TRUE;
+            UNLOCK( sink );
+            if (eosDetected) {
+               gst_element_post_message (GST_ELEMENT_CAST(sink), gst_message_new_eos(GST_OBJECT_CAST(sink)));
+            }
+         }
+         gst_event_unref (event);
+         break;
+         
+      #ifdef USE_GST1
+      case GST_EVENT_SEGMENT:
+      #else
+      case GST_EVENT_NEWSEGMENT:
+      #endif
+         {
+            gint64 segmentStart, segmentPosition;
+            GstFormat segmentFormat;
+            gdouble appliedRate = 1.0;
+
+            #ifdef USE_GST1
+            const GstSegment *dataSegment;
+            gst_event_parse_segment(event, &dataSegment);
+            segmentFormat= dataSegment->format;
+            segmentStart= dataSegment->start;
+            segmentPosition= dataSegment->position;
+            appliedRate= dataSegment->applied_rate;
+            #else
+            gst_event_parse_new_segment(event, NULL, NULL, 
+                                        &segmentFormat, &segmentStart, 
+                                        NULL, &segmentPosition);
+            #endif
+            
+            GST_LOG_OBJECT(sink, 
+                           "segment: start %" GST_TIME_FORMAT ", position %" GST_TIME_FORMAT,
+                            GST_TIME_ARGS(segmentStart), GST_TIME_ARGS(segmentPosition));
+
+            
+            LOCK( sink );
+            sink->currentSegment = dataSegment;
+            sink->flushStarted= FALSE;
+            if (appliedRate != 1.0)
+            {
+                GST_DEBUG_OBJECT(sink, "rate change done upstream");
+                sink->queryPositionFromPeer= TRUE;
+            }
+            
+            if ( 
+                 (segmentFormat == GST_FORMAT_TIME) && 
+                 ( (segmentStart != 0) || (sink->startPTS != 0) )
+               ) 
+            {
+               sink->segmentNumber++;
+               sink->eosEventSeen= FALSE;
+               sink->eosDetected= FALSE;
+               sink->position= GST_TIME_AS_NSECONDS(segmentStart);
+               sink->positionSegmentStart= GST_TIME_AS_NSECONDS(segmentStart);
+               sink->startPTS= (GST_TIME_AS_MSECONDS(segmentStart)*90LL);
+            }
+            UNLOCK( sink );
+            gst_event_unref (event);
+         }
+         break;
+       default:
+         //passToDefault= TRUE;
+         result = gst_pad_event_default (pad, parent, event);
+         break;
+   }
+
+#if 0
+   if (passToDefault && sink->parentEventFunc)
+   {
+      #ifdef USE_GST1
+      result= sink->parentEventFunc(pad, parent, event);
+      #else
+      result= sink->parentEventFunc(pad, event);
+      #endif
+   }
+   else
+   {
+      gst_event_ref(event);
+   }
+
+   #ifndef USE_GST1
+   gst_object_unref(sink);
+   #endif
+#endif
+  
+   return result;
+}
+
+#if 0
+#ifdef USE_GST1
+static gboolean gst_westeros_sink_sink_query(GstPad *pad, GstObject *parent, GstQuery *query)
+{
+   GstWesterosSink *sink= GST_WESTEROS_SINK(parent);
+#else
+static gboolean gst_westeros_sink_sink_query(GstPad *pad, GstQuery *query)
+{
+   GstWesterosSink *sink= GST_WESTEROS_SINK(gst_pad_get_parent(pad));
+#endif
+
+   gboolean rv = FALSE;
+
+   rv = gst_westeros_sink_soc_query(sink, query);
+
+   if (rv == FALSE)
+   {
+      #ifdef USE_GST1
+      rv= sink->defaultQueryFunc(pad, parent, query);
+      #else
+      rv= sink->defaultQueryFunc(pad, query);
+      #endif
+   }
+
+   return rv;
+}
+
+static gboolean gst_westeros_sink_check_caps(GstWesterosSink *sink, GstPad *peer)
+{
+   WESTEROS_UNUSED(sink);
+
+   gboolean result= TRUE;
+   GstCaps* caps= NULL;
+
+#ifdef USE_GST1
+   caps= gst_pad_query_caps(peer, NULL);
+#else
+   caps= gst_pad_get_caps(peer);
+#endif
+  
+   if (gst_caps_get_size(caps) == 0)
+   {
+      result= TRUE;
+      goto exit;
+   }
+
+   if ( !gst_westeros_sink_soc_accept_caps( sink, caps ) )  
+   {
+      result= FALSE;
+      goto exit;
+   }
+
+exit:
+   if ( caps )
+   {
+      gst_caps_unref(caps);
+   }
+
+   return result;
+}
+
+#ifdef USE_GST1
+GstPadLinkReturn gst_westeros_sink_link(GstPad *pad, GstObject *parent, GstPad *peer)
+{
+   GstWesterosSink *sink= GST_WESTEROS_SINK(parent);
+#else
+static GstPadLinkReturn gst_westeros_sink_link(GstPad *pad, GstPad *peer)
+{
+   GstWesterosSink *sink= GST_WESTEROS_SINK(gst_pad_get_parent(pad));
+#endif
+   GstElement *pElement;
+
+   GST_DEBUG_OBJECT(sink, "gst_westeros_sink_link: enter");
+   
+   if (gst_westeros_sink_check_caps(sink, peer) != TRUE)
+   {
+      GST_ERROR("Peer Caps is not supported\n");
+   }
+
+   gchar *peerName= gst_pad_get_name(peer);
+   pElement= (GstElement*)gst_pad_get_parent_element(pad); 
+   if (pElement)
+   {
+      gst_object_unref(pElement);
+   }
+
+   pElement= (GstElement*)gst_pad_get_parent_element(peer);
+   if(pElement)
+   {
+      gst_object_unref(pElement);
+   }
+
+   sink->peerPad= peer;
+   g_free(peerName);  
+   
+   GST_DEBUG_OBJECT(sink, "gst_westeros_sink_link: startAfterLink %d", sink->startAfterLink);
+   if ( sink->startAfterLink )
+   {
+      sink->startAfterLink= FALSE;
+      gst_westeros_sink_soc_start_video( sink );      
+   }
+
+   return GST_PAD_LINK_OK;
+}
+
+#ifdef USE_GST1
+static void gst_westeros_sink_unlink(GstPad *pad, GstObject *parent)
+{
+   WESTEROS_UNUSED(pad);
+   GstWesterosSink *sink= GST_WESTEROS_SINK(parent);
+#else
+static void gst_westeros_sink_unlink(GstPad *pad)
+{
+   GstWesterosSink *sink= GST_WESTEROS_SINK(gst_pad_get_parent(pad));
+#endif
+
+   GST_DEBUG_OBJECT(sink, "gst_westeros_sink_unlink");
+   sink->peerPad= NULL;
+   
+   return;
+}
+
+static GstFlowReturn gst_westeros_sink_render(GstBaseSink *base_sink, GstBuffer *buffer)
+{  
+   GstWesterosSink *sink= GST_WESTEROS_SINK(base_sink);
+   
+   LOCK( sink );
+   sink->eosDetected= FALSE;
+   UNLOCK( sink );
+
+   gst_westeros_sink_soc_render( sink, buffer );
+
+   return GST_FLOW_OK;
+}
+
+static GstFlowReturn gst_westeros_sink_preroll(GstBaseSink *base_sink, GstBuffer *buffer)
+{
+   GstWesterosSink *sink= GST_WESTEROS_SINK(base_sink);
+
+   WESTEROS_UNUSED(buffer);
+   
+   GST_DEBUG_OBJECT(sink, "gst_westeros_sink_preroll: enter: rejectPrerollBuffers: %d", sink->rejectPrerollBuffers);
+   if (sink->rejectPrerollBuffers)
+   {
+      #ifdef USE_GST1
+      return GST_FLOW_FLUSHING;
+      #else
+      return GST_FLOW_WRONG_STATE;
+      #endif
+   }
+
+   return GST_FLOW_OK;
+}
+
+void gst_westeros_sink_eos_detected( GstWesterosSink *sink )
+{
+   LOCK( sink );
+   gboolean eosEventSeen= sink->eosEventSeen;
+   sink->eosDetected= TRUE;
+   UNLOCK( sink );
+   if (eosEventSeen) {
+      GST_DEBUG_OBJECT(sink, "gst_westeros_sink_eos_detected: posting EOS");
+      gst_element_post_message (GST_ELEMENT_CAST(sink), gst_message_new_eos(GST_OBJECT_CAST(sink)));
+   }
+}
+#endif
+
+static gboolean westeros_sink_init (GstPlugin * plugin)
+{
+   gst_westeros_sink_soc_load();
+   return gst_element_register (plugin, "westerossink", GST_RANK_NONE, gst_westeros_sink_get_type ());
+}
+
+#ifndef PACKAGE
+#define PACKAGE "mywesterossink"
+#endif
+
+#ifdef USE_GST1
+GST_PLUGIN_DEFINE (
+    GST_VERSION_MAJOR,
+    GST_VERSION_MINOR,
+    westerossink,
+    "Writes buffers to the westeros wayland compositor",
+    westeros_sink_init, 
+    VERSION, 
+    "LGPL", 
+    PACKAGE_NAME,
+    GST_PACKAGE_ORIGIN )
+#else
+GST_PLUGIN_DEFINE (
+    GST_VERSION_MAJOR,
+    GST_VERSION_MINOR,
+   "westerossink",
+    "Writes buffers to the westeros wayland compositor",
+    westeros_sink_init, 
+    VERSION, 
+    "LGPL", 
+    PACKAGE_NAME,
+    GST_PACKAGE_ORIGIN )
+#endif
+
+
diff --git a/syna/westeros-sink/westeros-sink.h b/syna/westeros-sink/westeros-sink.h
new file mode 100644
index 0000000..04c4837
--- /dev/null
+++ b/syna/westeros-sink/westeros-sink.h
@@ -0,0 +1,151 @@
+/*
+ * If not stated otherwise in this file or this component's Licenses.txt file the
+ * following copyright and licenses apply:
+ *
+ * Copyright 2016 RDK Management
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#ifndef __WESTEROS_SINK_H__
+#define __WESTEROS_SINK_H__
+
+#include "wayland-client.h"
+#include "simpleshell-client-protocol.h"
+#include "vpc-client-protocol.h"
+
+#include <gst/gst.h>
+#include <gst/base/gstbasesink.h>
+
+#define DEFAULT_WINDOW_X (0)
+#define DEFAULT_WINDOW_Y (0)
+#define DEFAULT_WINDOW_WIDTH (1280)
+#define DEFAULT_WINDOW_HEIGHT (720)
+
+#define WESTEROS_UNUSED(x) ((void)(x))
+
+G_BEGIN_DECLS
+
+#define GST_TYPE_WESTEROS_SINK \
+  (gst_westeros_sink_get_type())
+#define GST_WESTEROS_SINK(obj) \
+  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_WESTEROS_SINK,GstWesterosSink))
+#define GST_WESTEROS_SINK_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_WESTEROS_SINK,GstWesterosSinkClass))
+#define GST_WESTEROS_SINK_GET_CLASS(obj)     (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_WESTEROS_SINK, GstWesterosSinkClass))
+#define GST_IS_WESTEROS_SINK(obj) \
+  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_WESTEROS_SINK))
+#define GST_IS_WESTEROS_SINK_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_WESTEROS_SINK))
+
+typedef struct _GstWesterosSink GstWesterosSink;
+typedef struct _GstWesterosSinkClass GstWesterosSinkClass;
+
+#define PROP_SOC_BASE (100)
+
+#include "westeros-sink-soc.h"
+
+struct _GstWesterosSink
+{
+   GstElement parent;
+#if 0
+   GstPadEventFunction parentEventFunc;
+   GstPadQueryFunction defaultQueryFunc;
+#endif
+   
+   GstPad *peerPad; 
+   gboolean rejectPrerollBuffers;
+   
+   gboolean initialized;
+   #ifdef GLIB_VERSION_2_32 
+   GMutex mutex;
+   #else
+   GMutex *mutex;
+   #endif
+   
+   int srcWidth;
+   int srcHeight;
+   int maxWidth;
+   int maxHeight;
+
+   int windowX;
+   int windowY;
+   int windowWidth;
+   int windowHeight;
+   bool windowChange;
+   bool windowSizeOverride;
+   
+   bool visible;
+   float opacity;
+   float zorder;
+   
+   int transX;
+   int transY;
+   int scaleXNum;
+   int scaleXDenom;
+   int scaleYNum;
+   int scaleYDenom;
+   int outputWidth;
+   int outputHeight;
+
+   gboolean videoStarted;
+   gboolean startAfterLink;
+   gboolean flushStarted;
+   
+   gboolean eosEventSeen;
+   gboolean eosDetected;
+   gint64 startPTS;
+   gint64 firstPTS;
+   gint64 currentPTS;
+   gint64 position;
+   gint64 positionSegmentStart;
+   gint64 prevPositionSegmentStart;
+   gboolean queryPositionFromPeer;
+   const GstSegment* currentSegment;
+
+   unsigned segmentNumber;
+   
+   struct wl_display *display;
+   struct wl_registry *registry;
+   struct wl_simple_shell *shell;
+   struct wl_compositor *compositor;
+   struct wl_event_queue *queue;
+   struct wl_surface *surface;
+   uint32_t surfaceId;
+   struct wl_vpc *vpc;
+   struct wl_vpc_surface *vpcSurface;
+   
+   struct _GstWesterosSinkSoc soc;
+};
+
+struct _GstWesterosSinkClass
+{
+   GstBaseSinkClass parent_class;
+   GstPadEventFunction sink_cb;
+};
+
+GType gst_westeros_sink_get_type (void);
+
+G_END_DECLS
+
+#ifdef GLIB_VERSION_2_32
+  #define LOCK( sink ) g_mutex_lock( &((sink)->mutex) );
+  #define UNLOCK( sink ) g_mutex_unlock( &((sink)->mutex) );
+#else
+  #define LOCK( sink ) g_mutex_lock( (sink)->mutex );
+  #define UNLOCK( sink ) g_mutex_unlock( (sink)->mutex );
+#endif
+
+void gst_westeros_sink_eos_detected( GstWesterosSink *sink );
+
+#endif
+
