commit 45a9f4513db9523df2d3131bb5b4cde91a6f0366
Author: Vijay Kumar Raju P <vijaykr@synaptics.com>
Date:   Wed Jan 3 18:18:22 2018 -0800

    ampsamples plugin

diff --git a/AMPSamples/AMPSamples.config b/AMPSamples/AMPSamples.config
new file mode 100644
index 0000000..0c23425
--- /dev/null
+++ b/AMPSamples/AMPSamples.config
@@ -0,0 +1,6 @@
+set (autostart ${WPEFRAMEWORK_PLUGIN_AMPSAMPLES_AUTOSTART})
+
+map()
+    kv(outofprocess ${WPEFRAMEWORK_PLUGIN_AMPSAMPLES_OOP})
+end()
+ans(configuration) # Plugin specific configuration
diff --git a/AMPSamples/AMPSamples.cpp b/AMPSamples/AMPSamples.cpp
new file mode 100644
index 0000000..b0fb8a0
--- /dev/null
+++ b/AMPSamples/AMPSamples.cpp
@@ -0,0 +1,118 @@
+#include "AMPSamples.h"
+
+namespace WPEFramework {
+
+namespace AMPSamples {
+
+    // An implementation file needs to implement this method to return an operational browser, wherever that would be :-)
+    extern Exchange::IMemory* MemoryObserver(const uint32 pid);
+}
+
+namespace Plugin {
+
+    SERVICE_REGISTRATION(AMPSamples, 1, 0);
+
+    /* encapsulated class Thread  */
+    /* virtual */ const string AMPSamples::Initialize(PluginHost::IShell* service)
+    {
+        Config config;
+        string message; 
+
+        ASSERT(_service  == nullptr);
+        ASSERT(_memory   == nullptr);
+        ASSERT(_ampsamples == nullptr);
+        _pid	 = 0;
+        _service = service;
+        _skipURL = _service->WebPrefix().length();
+        _service->Register(&_notification);
+        config.FromString(_service->ConfigLine());
+        if (config.OutOfProcess.Value() == true) {
+            _ampsamples = _service->Instantiate<Exchange::IAMPSamples>( 2000 , _T("AMPSamplesImplementation"), static_cast<uint32>(~0) , _pid, _service->Locator());
+        }
+        else {
+           _ampsamples = Core::ServiceAdministrator::Instance().Instantiate<Exchange::IAMPSamples>( Core::Library(), _T("AMPSamplesImplementation"), static_cast<uint32>(~0));
+        }
+
+        if (_ampsamples == nullptr) {
+            message  = _T("AMPSamples could not be instantiated.");
+            _service->Unregister(&_notification);
+            _service = nullptr;
+        }
+        else {
+            _memory  = WPEFramework::AMPSamples::MemoryObserver(_pid);
+            _ampsamples->Configure(_service->ConfigLine());
+            ASSERT (_memory !=nullptr);
+        }
+
+        return message;
+    }
+
+    /*virtual*/ void AMPSamples::Deinitialize(PluginHost::IShell* service)
+    {
+        ASSERT(_service  == service);
+        ASSERT(_memory   != nullptr);
+        ASSERT(_ampsamples != nullptr);
+
+        _service->Unregister(&_notification);
+        _memory->Release();
+
+        if (_ampsamples->Release() != Core::ERROR_DESTRUCTION_SUCCEEDED) {
+            ASSERT (_pid != 0);
+
+            TRACE_L1("AMPSamples Plugin is not properly destructed. %d", _pid);
+
+            RPC::IRemoteProcess* process (_service->RemoteProcess(_pid));
+
+            // The process can disappear in the meantime...
+            if (process != nullptr) {
+                process->Terminate();
+                process->Release();
+            }
+        }
+
+        // Deinitialize what we initialized..
+        _memory   = nullptr;
+        _ampsamples = nullptr;
+        _service  = nullptr;
+    }
+
+    /* virtual */ string AMPSamples::Information() const
+    {	
+        // No additional info to report.
+        return (nullptr);
+    }
+
+    /* virtual */ void AMPSamples::Inbound(WPEFramework::Web::Request& request)
+    {
+    }
+
+    /* virtual */ Core::ProxyType<Web::Response> AMPSamples::Process(const WPEFramework::Web::Request& request)
+    {	
+        ASSERT(_skipURL <= request.Path.length());
+
+        TRACE(Trace::Information, (string(_T("Received AMPSamples request"))));
+
+        Core::ProxyType<Web::Response> result(PluginHost::Factories::Instance().Response());
+
+        result->ErrorCode = Web::STATUS_OK;
+        result->Message = "OK";
+
+        return result;
+    }
+
+    void AMPSamples::Deactivated(RPC::IRemoteProcess* process)
+    {
+      if (process->Id() == _pid) {
+
+          ASSERT (_service != nullptr);
+
+          PluginHost::WorkerPool::Instance().Submit(PluginHost::IShell::Job::Create(_service,
+                                                   PluginHost::IShell::DEACTIVATED,
+                                                   PluginHost::IShell::FAILURE));
+        }
+    }
+
+}
+
+} //namespace WPEFramework::Plugin
+
diff --git a/AMPSamples/AMPSamples.h b/AMPSamples/AMPSamples.h
new file mode 100644
index 0000000..09e1b8f
--- /dev/null
+++ b/AMPSamples/AMPSamples.h
@@ -0,0 +1,133 @@
+#ifndef __AMPSAMPLES_H
+#define __AMPSAMPLES_H
+
+#include "Module.h"
+#include <interfaces/IMemory.h>
+#include <interfaces/IAMPSamples.h>
+
+namespace WPEFramework {
+namespace Plugin {
+
+    class AMPSamples : public PluginHost::IPlugin, public PluginHost::IWeb {
+    private:
+        AMPSamples(const AMPSamples&)=delete;
+        AMPSamples& operator=(const AMPSamples&)=delete;
+
+        class Notification :public RPC::IRemoteProcess::INotification {
+
+        private:
+            Notification()=delete;
+            Notification(const Notification&)=delete;
+            Notification& operator=(const Notification&)=delete;
+
+        public:
+            explicit Notification(AMPSamples* parent)
+                : _parent(*parent)
+            {
+                ASSERT(parent != nullptr);
+            }
+            ~Notification()
+            {
+            }
+
+        public:
+            virtual void Activated(RPC::IRemoteProcess* )
+            {
+            }
+            virtual void Deactivated(RPC::IRemoteProcess* process)
+            {
+                _parent.Deactivated(process);
+            }
+
+            BEGIN_INTERFACE_MAP(Notification)
+            	INTERFACE_ENTRY(RPC::IRemoteProcess::INotification)
+            END_INTERFACE_MAP
+
+        private:
+            AMPSamples&  _parent;
+        };
+
+        class Config : public Core::JSON::Container {
+        private:
+            Config(const Config&);
+            Config& operator=(const Config&);
+
+        public:
+            Config()
+                : Core::JSON::Container()
+                , OutOfProcess(true)
+            {
+                Add(_T("outofprocess"), &OutOfProcess);
+            }
+            ~Config()
+            {
+            }
+
+        public:
+            Core::JSON::Boolean OutOfProcess;
+        };
+
+    public:
+        AMPSamples()
+            : _service(nullptr)
+            , _ampsamples(nullptr)
+            , _memory(nullptr)
+            , _notification(this)
+        {
+        }
+
+        virtual ~AMPSamples()
+        {
+        }
+
+    public:
+        BEGIN_INTERFACE_MAP(AMPSamples)
+        	INTERFACE_ENTRY(PluginHost::IPlugin)
+        	INTERFACE_ENTRY(PluginHost::IWeb)
+		    INTERFACE_AGGREGATE(Exchange::IAMPSamples, _ampsamples)
+        	INTERFACE_AGGREGATE(Exchange::IMemory, _memory)
+        END_INTERFACE_MAP
+
+    public:
+        //  IPlugin methods
+        // -------------------------------------------------------------------------------------------------------
+
+        // First time initialization. Whenever a plugin is loaded, it is offered a Service object with relevant
+        // information and services for this particular plugin. The Service object contains configuration information that
+        // can be used to initialize the plugin correctly. If Initialization succeeds, return nothing (empty string)
+        // If there is an error, return a string describing the issue why the initialisation failed.
+        // The Service object is *NOT* reference counted, lifetime ends if the plugin is deactivated.
+        // The lifetime of the Service object is guaranteed till the deinitialize method is called.
+        virtual const string Initialize(PluginHost::IShell* service);
+
+        // The plugin is unloaded from the webbridge. This is call allows the module to notify clients
+        // or to persist information if needed. After this call the plugin will unlink from the service path
+        // and be deactivated. The Service object is the same as passed in during the Initialize.
+        // After theis call, the lifetime of the Service object ends.
+        virtual void Deinitialize(PluginHost::IShell* service);
+
+        // Returns an interface to a JSON struct that can be used to return specific metadata information with respect
+        // to this plugin. This Metadata can be used by the MetData plugin to publish this information to the ouside world.
+        virtual string Information() const;
+
+        //  IWeb methods
+        // -------------------------------------------------------------------------------------------------------
+        virtual void Inbound(Web::Request& request);
+        virtual Core::ProxyType<Web::Response> Process(const Web::Request& request);
+
+    private:
+        void Deactivated(RPC::IRemoteProcess* process);
+
+    private:
+        uint8                          _skipURL;
+        uint32                         _pid;
+        PluginHost::IShell*             _service;
+        Exchange::IAMPSamples*           _ampsamples;
+        Exchange::IMemory*             _memory;
+        Core::Sink<Notification>   _notification;
+    };
+} //namespace Plugin
+
+} //namespace Solution
+
+#endif // __AMPSAMPLES_H
diff --git a/AMPSamples/AMPSamplesImplementation.cpp b/AMPSamples/AMPSamplesImplementation.cpp
new file mode 100644
index 0000000..823157c
--- /dev/null
+++ b/AMPSamples/AMPSamplesImplementation.cpp
@@ -0,0 +1,131 @@
+#include "Module.h"
+#include "AMPSamples.h"
+
+#include <interfaces/IMemory.h>
+#include <interfaces/IAMPSamples.h>
+
+namespace WPEFramework {
+namespace Plugin {
+
+    class AMPSamplesImplementation: public Core::Thread, public Exchange::IAMPSamples {
+
+    public:
+        AMPSamplesImplementation(const AMPSamplesImplementation&) = delete;
+        AMPSamplesImplementation& operator=(const AMPSamplesImplementation&) = delete;
+
+    public:
+        AMPSamplesImplementation()
+            : Core::Thread(0, _T("AMPSamples"))
+        {
+            // Register an @Exit, in case we are killed, with an incorrect ref count !!
+            if (atexit(AMPSamplesImplementation::CloseDown) != 0) {
+                TRACE_L1("Could not register @exit handler. Error: %d.", errno);
+                exit(EXIT_FAILURE);		
+            }
+
+            // AMPSamples can only be instantiated once (it is a process wide singleton !!!!)
+            ASSERT(_implementation == nullptr);
+
+            _implementation = this;
+        }
+
+        virtual ~AMPSamplesImplementation()
+        {
+            system("/usr/bin/wpe_ampsamples_plugin_stop.sh");
+            _implementation = nullptr;
+        }
+
+        virtual uint32 Configure(const string& config)
+        {
+            uint32 result = Core::ERROR_NONE;
+            Run();
+            return (result);
+        }
+
+
+        BEGIN_INTERFACE_MAP(AMPSamplesImplementation)
+	    INTERFACE_ENTRY(Exchange::IAMPSamples)
+        END_INTERFACE_MAP
+
+    private:
+        virtual uint32 Worker()
+        {
+            system("/usr/bin/wpe_ampsamples_plugin_start.sh");
+            return (Core::infinite);
+        }
+
+        static void CloseDown () {
+            // Seems we are destructed.....If we still have a pointer to the implementation, Kill it..
+            if (_implementation != nullptr) {
+                delete _implementation;
+                _implementation = nullptr;
+            }
+        }
+
+    private:
+        static AMPSamplesImplementation* _implementation;
+    };
+
+    SERVICE_REGISTRATION(AMPSamplesImplementation, 1, 0);
+
+    /* static */ AMPSamplesImplementation* AMPSamplesImplementation::_implementation = nullptr;
+
+} /* namespace Plugin */
+
+namespace AMPSamples{
+
+    class MemoryObserverImpl : public Exchange::IMemory {
+    private:
+        MemoryObserverImpl();
+        MemoryObserverImpl(const MemoryObserverImpl&);
+        MemoryObserverImpl& operator=(const MemoryObserverImpl&);
+
+    public:
+        MemoryObserverImpl(const uint32 id)
+            : _main(id == 0 ? Core::ProcessInfo().Id() : id)
+        {
+        }
+        ~MemoryObserverImpl()
+        {
+        }
+
+    public:
+        virtual uint64 Resident() const
+        {
+            return (_main.Resident());
+        }
+        virtual uint64 Allocated() const
+        {
+            return (_main.Allocated());
+        }
+        virtual uint64 Shared() const
+        {
+            return (_main.Shared());
+        }
+        virtual uint8 Processes() const
+        {
+            return (1);
+        }
+        virtual const bool IsOperational() const
+        {
+            return (_main.IsActive());
+        }
+        virtual void Observe(const bool enable)
+        {
+        }
+
+        BEGIN_INTERFACE_MAP(MemoryObserverImpl)
+	    INTERFACE_ENTRY(Exchange::IMemory)
+        END_INTERFACE_MAP
+
+    private:
+        Core::ProcessInfo _main;
+   
+    };
+
+    Exchange::IMemory* MemoryObserver(const uint32 PID)
+    {
+        return (Core::Service<MemoryObserverImpl>::Create<Exchange::IMemory>(PID));
+    }
+
+}
+
+} // namespace WPEFramework::AMPSamples
+
diff --git a/AMPSamples/CMakeLists.txt b/AMPSamples/CMakeLists.txt
new file mode 100644
index 0000000..5865e7a
--- /dev/null
+++ b/AMPSamples/CMakeLists.txt
@@ -0,0 +1,28 @@
+set(PLUGIN_NAME AMPSamples)
+
+set(WPEFRAMEWORK_PLUGIN_AMPSAMPLES_AUTOSTART false CACHE STRING true)
+set(WPEFRAMEWORK_PLUGIN_AMPSAMPLES_OOP false CACHE STRING true)
+
+include(module) # Setup default stuff needed for the cmake framework thingy.
+
+find_package(AMPSDK REQUIRED)
+
+set(PLUGIN_DEPENDENCIES_INCLUDE_DIRS
+        ${AMPSDK_INCLUDE_DIRS}
+        )
+set(PLUGIN_DEPENDENCIES
+        ${AMPSDK_LIBRARIES}
+        )
+
+set(PLUGIN_DEFINITIONS)
+set(PLUGIN_OPTIONS)
+set(PLUGIN_LINK_OPTIONS)
+set(PLUGIN_SOURCES 
+        Module.cpp
+        AMPSamples.cpp
+        AMPSamplesImplementation.cpp
+        )
+
+include(default_targets) # This is a regular plugin no need to edit the defaults
+
+write_config(${PLUGIN_NAME})
diff --git a/AMPSamples/Module.cpp b/AMPSamples/Module.cpp
new file mode 100644
index 0000000..2d85ed9
--- /dev/null
+++ b/AMPSamples/Module.cpp
@@ -0,0 +1,3 @@
+#include "Module.h"
+
+MODULE_NAME_DECLARATION(BUILD_REFERENCE)
diff --git a/AMPSamples/Module.h b/AMPSamples/Module.h
new file mode 100644
index 0000000..4ae7c42
--- /dev/null
+++ b/AMPSamples/Module.h
@@ -0,0 +1,13 @@
+#ifndef __MODULE_PLUGIN_AMPSAMPLES_MODULE_H
+#define __MODULE_PLUGIN_AMPSAMPLES_MODULE_H
+
+#ifndef MODULE_NAME
+#define MODULE_NAME Plugin_AMPSamples
+#endif
+
+#include <plugins/plugins.h>
+
+#undef EXTERNAL
+#define EXTERNAL
+
+#endif // __MODULE_PLUGIN_AMPSAMPLES_MODULE_H
diff --git a/CMakeLists.txt b/CMakeLists.txt
index c3194a9..8140302 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -101,6 +101,7 @@ option(WPEFRAMEWORK_PLUGIN_WEBSHELL "Include WebShell plugin" OFF)
 option(WPEFRAMEWORK_PLUGIN_TVCONTROL "Include TVControl plugin" OFF)
 option(WPEFRAMEWORK_PLUGIN_WIFISETUP "Include WifiSetup plugin" OFF)
 option(WPEFRAMEWORK_PLUGIN_POWER "Include Power plugin" OFF)
+option(WPEFRAMEWORK_PLUGIN_AMPSAMPLES "Include AMPSamples plugin" OFF)
 
 include_directories(${WPEFRAMEWORK_PLUGINS_INCLUDE_DIRS})
 
@@ -187,3 +188,7 @@ endif()
 if(WPEFRAMEWORK_PLUGIN_POWER)
     add_subdirectory(Power)
 endif(WPEFRAMEWORK_PLUGIN_POWER)
+
+if(WPEFRAMEWORK_PLUGIN_AMPSAMPLES)
+    add_subdirectory(AMPSamples)
+endif()
diff --git a/cmake/FindAMPSDK.cmake b/cmake/FindAMPSDK.cmake
new file mode 100644
index 0000000..b27131a
--- /dev/null
+++ b/cmake/FindAMPSDK.cmake
@@ -0,0 +1,12 @@
+find_path (AMP_INCLUDE_DIR NAME amp_client.h PATH_SUFFIXES marvell/amp/inc)
+find_path (OSAL_INCLUDE_DIR NAME OSAL_api.h PATH_SUFFIXES marvell/osal/include)
+
+find_library(AMP_LIB NAME libampclient.so PATH_SUFFIXES lib)
+       set (AMPSDK_INCLUDE_DIRS ${OSAL_INCLUDE_DIR} ${AMP_INCLUDE_DIR})
+
+include(FindPackageHandleStandardArgs)
+set (AMPSDK_INCLUDE_DIRS ${OSAL_INCLUDE_DIR} ${AMP_INCLUDE_DIR} CACHE PATH "Path to header")
+set (AMPSDK_LIBRARIES ${AMP_LIB} CACHE PATH "path to ocdmi library")
+FIND_PACKAGE_HANDLE_STANDARD_ARGS(AMPSDK DEFAULT_MSG AMPSDK_INCLUDE_DIRS AMPSDK_LIBRARIES)
+
+mark_as_advanced(AMPSDK_INCLUDE_DIRS AMPSDK_LIBRARIES)
